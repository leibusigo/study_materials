#### 0、HTML和CSS的常见面试题

###### 0.1 谈谈你对标签语义化的理解

HTML语义化简单来说就是用正确的标签做正确的事；

HTML语义化能够让页面的内容与结构更加清晰，便于对浏览器和搜索引擎的解析。

###### 0.2 你用过哪些HTML5标签

表示结构的标签：

`<header></header>、<section></section>、<footer></footer>、<nav><nav>、<aside></aside>、<main></main>、<article></article>、<figure></figure>`

表示日期和时间值： `<time></time>`

表示高亮文本：`<mark></mark>`

表示音频和视频：`<audio></audio>、<video></video>`

通过JS绘制图形：`<canvas></canvas>`

###### 0.3 行内元素有哪些？块级元素有哪些？空元素有哪些？

* 行内元素： a, b, span, img, input, select, strong
* 块级元素：div, p, h1~h6, ul, ol, li
* 空元素：br, hr, input, img, link

###### 0.4 页面导入样式时，采用link和@import有什么区别

* link是建立当前页面与外部资源文件的联系，而@import是下载导入文件
* 加载页面时，link标签引入的css被同时加载，而@Import引入的css会在页面加载完毕后加载。

###### 0.5 介绍一下你对浏览器内核的理解

浏览器内核分为两个部分： 渲染引擎和JS引擎

* 渲染引擎：是用来解析HTML并将解析后的内容渲染到页面上的
* JS引擎：是用来解析和执行JS脚本控制DOM并进行交互的

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎

**常用的浏览器内核：**

IE:   Trident

FireFox:   Gecko

Chrome/Opera:   Blink

Safari:   Webkit

###### 0.6 Cookie、localStorage和sessionStorage的区别（和token、session）

* cookie始终在同源的HTTP请求中携带，即cookie始终在浏览器和客户端之间来回传递；localStorage和sessionStorage不会自动把数据传递给服务器，仅在本地保存；
* 存储大小不同：cookie存储的数据不能超过4K，只适合保存很小的数据，例如回话标识；localStorage和sessionStorage存储的数据可以达到5M或更大；
* 数据有效期不同：cookie只在设置的过期时间之前一直有效，即使浏览器窗口关闭；sessionStorage仅在当前的浏览器窗口关闭前有效；localStorage长期有效，即使浏览器或窗口关闭也保存；
* 作用域不同：cookie是在所有的同源窗口中是共享的；sessionStorage不在不同的浏览器和窗口中共享；localStorage在所有的同源窗口中是共享的。

**token的理解：**

1、token的获取方式：

* 登录之后，自动生成token
* 通过一个特定的获取token的接口去获取token 

然后后面的每一次请求都必须带上token实现鉴权。

**cookie和session的区别：**

* 存储位置不同：cookie数据存放在客户端，而session数据存放在服务器上；
* 存储的类型不同：cookie只支持字符串数据，想要设置其他类型的数据，需要先将其转换为字符串，session可以存储任意类型的数据；
* 存储大小不同：cookie一般保存的数据比较小，在4kb之内；session可存储的数据远大于cookie；
* 有效期不同：cookie一般在所设置的过期时间之前有效，而session一般失效时间较短，客户端关闭或者session超时都会失效。



###### 0.7 谈谈你对BFC的理解

`BFC` 全称：`Block Formatting Context`， 名为 "块级格式化上下文"。

`W3C`官方解释为：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`BFC`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

简单来说，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

**怎样触发BFC：**

* 根元素，即HTML
* float的值不为none
* overflow的值不为visible
* display的值为inline-block或table-cell、flex
* position的值为absolute或fixed

###### 0.8 translate2d与translate3d

* **transform：2D转换：二维坐标系**

  转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果。

  * 移动：translate
  * 旋转：rotate
  * 缩放：scale

1）2D转换之移动（translate）

2D移动是2D转化里面的一种功能，可以改变元素在页面中的位置，类似于定位。

```css
transform:translate(x, y); /* 或者分开写 */
transform:translateX(n);
transform:translateY(n);
```

注意：

* 定义2D转换中的移动，沿着X和Y轴移动元素；
* translate最大的优点：不会影响到其他元素的位置；
* translate中的百分比单位是相对于自身元素的宽度和高度;
* 对行内标签没有效果.

2）2D转换之旋转（rotate）

2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转.

```css
transform:rotate(度数);
```

注意:

* rotate里面跟度数,单位是deg,比如rotate(45deg);
* 角度为正时是顺时针旋转,角度为负时,是逆时针旋转;
* 默认旋转的中心点是元素的中心点.

**2D转换中心点:transform-origin**

可以设置元素转换的中心点:

```css
transform-orgin:x y
```

注意:

* 后面的参数x和y用空格隔开
* x y默认转换的中心点是元素的中心点(50% 50%)
* 还可以给x y设置像素或者方位名词(top bottom left right center)

3）2D转换之缩放（scale）

缩放,顾名思义,可以放大和缩小.只要给元素添加上了这个属性就能控制它放大还是缩小.

```css
transform:scale(x, y);
```

注意:

* 其中x和y用逗号分隔;
* transform:scale(1, 1):宽和高都放1倍大,相当于没有放大;
* transform:scale(2, 2):宽和高都放2倍大
* transform:scale(2):只写一个参数,第二个参数则和第一个参数一样,相当于scale(2,2)
* transform:scale(0.5, 0.5):长和宽都缩小二分之一
* scale缩放最大的优势:可以设置转换中心点缩放,默认以中心点缩放的,而且不影响其他盒子.

4)2D转换的综合写法:

注意:

* 同时使用多个转换,其格式为:

`transform:translate() rotate() scale()`

* 其顺序会影响转换的结果(先旋转为改变坐标轴的方向);
* 当我们同时有位移和其他属性的时候,记得要将位移放到最前面.

###### 0.9 SPA(Single Page Application)

SPA 是一种特殊的 Web 应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的。它将所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载相应的 HTML 、 JavaScript 、 CSS 。一旦页面加载完成， SPA 不会因为用户的操作而进行页面的重新加载或跳转，而是利用 JavaScript 动态的变换 HTML，从而实现UI与用户的交互。在 SPA 应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region（区域）中的视图切换来展示内容。

1、优点：

1）有良好的交互体验：能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载；

2）前后端分离开发：单页Web应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，在客户端也可以分解为静态页面和页面交互两个部分；

3）减轻服务器压力：服务器只用提供数据即可，不用展示逻辑和页面合成，吞吐能力会提高几倍；

4）共用一套后端程序代码：不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；

2、缺点：

1）不利于SEO：由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势；

2）前进、后退管理困难：由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现；

3）初次加载耗时多：为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；



####  1、关于盒子水平垂直居中的六大方案

------

###### 1.1 定位1（已知盒子宽高）

需要知道盒子具体的宽高

```css
.div {
    position: relative;
}

//假设盒子的 width: 100px , height: 50px
.box {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -25px;
    margin-left: -50px;
}
```

###### 1.2 定位2（盒子有宽高但无需考虑）

盒子要有宽高但不用考虑盒子的宽高

```css
.div {
    position: relative;
}

.box {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
```

###### 1.3 定位3（css3中的transform）

不需要考虑盒子的宽高，但是可能会存在兼容性不是很好的问题

```css
.div {
    position: relative;
}

.box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%)
}
```

###### 1.4 利用flex布局

利用css3的flex布局，更加简单，但是也会存在兼容性不是很好的问题

```css
.div {
    display: flex;
    justify-conent: center;
    align-items: center;
}
```

###### 1.5 通过JavaScript来实现

父级的宽高减去盒子的宽高除二

```javascript
let divW  = app.offsetWidth,
    divH  = app.offsetHeight,
    boxW  = box.offsetWidth,
    boxH  = box.offsetHeight;
app.style.position = 'relative';
box.style.position = 'absolute';
box.style.left = (divW - boxW) / 2 + 'px';
box.style.top = (divH - boxH) / 2 + 'px';
```

###### 1.6 通过 display: table-cell

原本`display: table-cell`是控制文本的水平和居中的，但是只要将盒子设置为`inline`或者`inline-block`即可。

要求父级文本要有固定宽高。

```css
.div {
    display: table-cell;
    vertical-align: middle;
    text-align: center;
    /* 要有固定宽高 */
    width: 500px;
    height: 500px;
}
.box {
    display: inline-block;
}
```

###### 1.7 通过栅格布局grid实现

```css
.div {
        height: 300px;
        width: 300px;
        background-color: pink;
        display: grid;
    }

.box {
        height: 100px;
        width: 100px;
        background-color: lightblue;
        align-self: center;
        justify-self: center;
    }
```



 #### 2、关于Css3中的盒子模型

------

###### 2.1 标准盒子模型（box-sizing: content-box）

标准盒子模型的宽和高为内容本身的宽和高。

<img src="https://img-blog.csdnimg.cn/20191015101944496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbDE1MDM5NzE4MTA3,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

###### 2.2 IE盒子模型（box-sizing: border-box）

IE盒子模型的宽和高为：内容的宽和高+padding+border

<img src="https://img-blog.csdnimg.cn/20191015101803562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzbDE1MDM5NzE4MTA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />



#### 3、掌握几大经典布局方案（左右固定，中间自适应）

------

###### 3.1 圣杯布局

浮动和负的margin

中间的盒子放在最前面

圣杯布局是用一个大的盒子把中间和左右两个盒子都包起来了。

```html
<style>
    html,
    body {
        height: 100%;
        overflow: hidden;
        margin: 0; /* 消除浏览器的8个像素的干扰 */
    }

    .container {
        height: 100%;
        padding: 0 200px;
    }

    .left,
    .right {
        width: 200px;
        min-height: 200px;
        background: lightblue;
    }

    .center {
        width: 100%;
        min-height: 400px;
        background: lightsalmon;
    }

    .center,
    .left,
    .right {
        float: left;
    }

    .left {
        margin-left: -100%;
        position: relative;
        left: -200px;
    }
    
    .right {
        margin-right: -200px;
    }
</style>
<body>
    <div class="container" clearfix>
        <div class="center"></div>
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>
```

###### 3.2 双飞翼布局

姑且理解为和圣杯布局一样吧。

个人认为：圣杯布局是一个container包了center、left和right(圣杯是一体的)。

而双飞翼布局是一个container只包了center，left和right是和container脱离的（两个翅膀是分开的）。

双飞翼布局也要把中间的盒子放在最前面

双飞翼布局只有中间的盒子用了一个大盒子包裹了起来。是因为中间的块级元素如果给他左右两边的margin的时候，会导致整个块级元素发生变化，可能造成布局问题。如果用个大的盒子把他包裹起来的话，再给中间部分margin值，他只会相对于它的父元素进行缩进，不会造成形变。 

###### 3.3 使用flex

```html
<style>
 html,
 body {
     height: 100%;
     overflow: hidden;
     margin: 0;
 }

 .container {
     display: flex;
     height: 100%;
     justify-content: space-between;
 }

 .left,
 .right {
     flex: 0 0 200px;  /* 缩小的比例 放大的比例 在整个空间中所占的大小 */
     min-height: 200px;
     background: lightskyblue;
 }

 .center {
     flex: 1;  /* 把剩余空间全部占满 */
     min-height: 200px;
     background: lightsalmon;
 }
</style>

<body>
    <div class="container">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>

</body>
```

###### 3.4 通过定位实现

子绝父相，把左右两个盒子定位到两边的位置即可。

```html
<style>
 html,
 body {
     height: 100%;
     overflow: hidden;
     margin: 0;
 }

.left,
.right {
    position: absolute;
    width: 200px;
    min-height: 200px;
    background: lightskyblue;
    top: 0;
}

.container {
    position: relative;
    height: 100%;
}

.center {
    margin: 0 200px;
    min-height: 400px;
    background: lightsalmon;
}

.left {
    left: 0;
}

.right {
    right: 0;
}
</style>

<body>
    <div class="container">
        <div class="left"></div>
        <div class="center"></div>
        <div class="right"></div>
    </div>

</body>
```



#### 4、移动端响应式布局开发的三大方案

------

 

 

#### 5、堆栈内存及闭包作用域

------

###### 5.1 JS中的8种数据类型及区别

* 基本数据类型

  * String

  * Number

  * Boolean

  * Null

    null表示“没有对象”，即此处不应该有值。其典型用法是：

    * 作为函数的参数，表示该函数的参数不是对象；
    * 作为原型链的终点。

  * Undefined

    undefined表示“缺少值”，即此处应该有一个值，但是还没有定义。其典型用法是：

    * 变量被声明了，但是没有赋值时，就等于undefined；
    * 调用函数时，应该提供的参数没有提供，该参数等于undefined；
    * 对象没有赋值的属性，该属性的值为undefined；
    * 函数没有返回值时，默认返回undefined。

  * Symbol
    * symbol的值是唯一的，用来解决命名冲突的问题
    * symbol的值不能与其他数据进行运算
    * symbol定义的对象不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名。

* 引用数据类型

  * Object

  如果将一个对象作为引用类型的属性名的话，那么这个这个属性名会被转换成[Object Object]

  ```javascript
  let a = {},
      b = {
          n: '1'
      },
      c = {
          m: '2'
      };
  a[b] = "nihao";
  a[c] = "hello";
  console.log(a[b]); // hello
  
  /* 
  a[b] = "nihao"，堆中变为 [Object Object] : "nihao"
  a[c] = "hello",堆中变为  [Object Object] : "hello"
  两次虽然是不同的值，但是转化的属性名是一样的，因此第二次会将第一次的内容覆盖掉
  最终堆中只剩  [Object Object] : "hello"
  因此最终打印的尽管是 a[b]，但是转化完之后还是 [Object Object]，所以打印的结果为 “hello"
  */
```

  **数组和对象的区别：**

  1）数组表示有序数据的集合，而对象表示无序数据的集合。

  2）数组的数据没有”名称”（name），对象的数据有”名称”（name）。

  3）数组和对象的本质区别：`__proto__`有没有指向数组的共用属性。数组不直接指向，对象直接指向；数组是有特殊原型链的对象。

  * Function



###### 5.2 JS堆栈内存的运行机制

* 堆：存储引用类型值的空间
* 栈：存储基本类型值和指定代码的环境

同一个对象的属性名不能重复，数字和字符串**作为属性名**时是相等的，可相互覆盖。



###### 5.3 变量提升机制

当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所有带`var``function` 的关键词进行提前声明或者定义，这种预处理机制被称为`变量提升`。

```text
[变量提升阶段]
	带`var`的只声明未赋值
	带`function`的声明和赋值都完成了
```

* 变量提升只发生在当前作用域

预编译的问题：预编译的时候发生了那些事情？

```text
1、创建了AO对象；
2、找形参和变量声明作为AO对象的属性名，值是undefined；
3、实参和形参相统一，将实参的值覆盖undefined；
4、找函数声明，会覆盖变量的声明。
```

```js
function fn(a, c) {
    console.log(a);  // function a() {}
    var a = 123;
    console.log(a);  // 123
    console.log(c);  //function c() {}
    function a() {};
    if(false) {
        var d= 678;
    }
    console.log(d);  // undefined
    console.log(b);  // undefined
    var b = function () {};
    console.log(b);  // function () {}
    function c() {};
    console.log(c);  // function c() {}
}
fn(1, 2);

/* 
	AO:[
		a: undefined  1  function a() {}
		c: undefined  2  function c() {}
		d: undefined
		b: undefined  
	]
	
*/
```



###### 5.4 作用域和作用域链

*作用域：*就是一个独立的环境，让变量不会外泄暴露出去。也就是说作用域最大的用处就是用来隔离变量，让不同作用域下的变量不会有冲突。

* ES6之前的作用域

  * 全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域

    * 最外层函数和在最外层函数外面定义的变量拥有全局作用域
    * 变量未声明直接赋值会拥有全局作用域
    * 所有`window`对象的属性拥有全局作用域

    全局作用域的缺点：如果写了很多行JS代码，它们都在全局作用域中，这样就会污染命名空间，容易引起命名冲突。

  * 函数作用域：是指声明在函数内部的变量，和全局作用域相反，函数作用域一般只在函数内部可访问到

**注意：**块语句（大括号`{}`中间的语句，如`if`和`switch`条件语句或`for`和`while`循环语句，不像函数，它们不会创建一个新的作用域）

```js
if(true) {
    var a = 10;
    console.log(a); // 10
}
console,log(a); // 10
```

* ES6之后的作用域
  * 块级作用域：块级作用域可通过新增命令`let`和`const`声明，所声明的变量在指定的块级作用域外无法访问

```text
let特性：
1、块级作用域；
2、不存在变量提升；
3、不影响作用域链；
4、变量不能重复声明；

const特性：
1、块级作用域；
2、一定要赋初始值；
3、常量的值不能修改；
4、对数组和对象中元素的修改不算是对常量的修改，不会报错。
```

*作用域链：*一般情况下，变量的取值是到创建这个变量的函数作用域中去取值，但是如果在当前作用域中没有查到，就会向上级作用域去查，知道查到全局作用域，这么一个查找过程形成的链条就叫作用域链。



###### 5.5 闭包的两大作用：保存/保护

*闭包：*可以访问到其他函数内部作用域中变量的函数。

```js
(function () {
        var a = 10;
        function fn() {
            a++;
        }
    })();

/*
	上面function中的a++表明function这个函数可以访问到外面这个立即执行函数的作用域中的变量a，这就是一个闭包。
*/
```

*闭包的作用：*

* 保护：函数执行会形成一个全新的私有作用域，保护里面的变量不受外界干扰，这种保护机制就是闭包。

```text
例如：jQuery的源码中有大量的方法，为了防止它与我们自己所写的方法产生冲突，就采用了一个匿名自执行函数将其包裹了起来，使得jQuery库中的方法不受外界的干扰。
jQuery中所采用的匿名自执行函数：!function(){}()
这种就是闭包的其中一个作用：保护。
```

* 保存：

闭包的另一个作用是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。这种写法可以用在把一些不经常变动计算起来又比较复杂的值保存起来，节省每次的访问时间。



###### 5.6 JS编译机制： VO/AO/GO

*VO（Variable Object，变量对象）：*是一个用来保存`当前上下文`中所有变量的对象（存储空间），这个对象（存储空间）被创建在`当前上下文`中。

* AO（Active Object，私有对象）:

为了保存当前函数上下文中的所有变量，特意创建了一个对象，称之为`私有对象变量AO`，函数内所需的变量就都保存在`私有对象变量AO`中，所以在函数执行上下文中，变量对象VO的具体表现就是AO.

* GO（Global Object，全局对象）:

浏览器把所有后期需要供JS调取使用的属性和方法都放置在了GO当中，并且在全局中创建了一个叫做window的变量指向它。通过使用全局对象，可以访问所有其他所预定义的对象、函数和属性。



###### 5.7 JS高阶编程技巧：高阶函数与柯里化函数

*高阶函数：*接收一个或多个函数作为参数并且返回的是一个函数。

*柯里化函数：*柯里化（Currying）是把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并且返回接收余下的参数且返回结果的新函数的技术。

总结：说白了柯里化就是用到了很多闭包、递归、参数展开、绑定调用对象来满足一个功能函数的适用性，让使用这个功能的函数能加强健，可以在开发中非常优雅的处理复杂的逻辑。

```js
/* 
	经典面试题:
	add(1)(2)(3) = 6;
	add(1, 2, 3)(4) = 10;
	add(1)(2)(3)(4)(5) = 15;
*/

function add() {
        let args = Array.prototype.slice.call(arguments);
        let inner = function () {
            args.push(...arguments);
            return inner;
        }
        inner.toString = function() {
            return args.reduce( (pre, cur) => {
                return pre + cur;
            });
        }
        return inner;
    }
    console.log(add(1)(2, 3)(4));
```

#### 6、面向对象（OOP）和this处理

------

###### 6.1 惰性函数和单例设计模式

*惰性函数：*表示函数执行的分支只会在函数第一次调用时执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。

```js
/*
        DOM2事件绑定：
        1)元素.addEventListener()
        2)元素.attachEvent()
 */
    function emit(element, type, func) {
        if(element.addEventListener) {
            emit = function(element, type, func) {
                element.addEventListener(type, func, false);
            };
        } else if(element.attachEvent) {
            emit = function(element, type, func) {
                element.attachEvent('on' + type, func);
            };
        } else {
            emit = function(element, type, func) {
                element['on' + type]  =func;
            };
        }
        emit(element, type, func);
    }

    emit(box, 'click', fn1);
    emit(box, 'click', fn2);
```

*单例设计模式：*保证一个类仅有一个实例，用一个变量来保存当前是否已经为某个类创建实例对象，如果有这个实例了就直接返回该实例对象，如果没有就重新实例化。对于频繁创建、销毁对象，这个单例模式实现了对象同意，内存只占有一个对象内存的分量，在频繁的创建中大大的节约了系统的内存。

```js
/*
	单例设计模式的核心代码
*/
function Person() {
    this.name = 'mavis';
}
// 用一个变量来保存当前是否已经为某个类创建实例对象
let instance = null; 
function singleTon() {  
    // 如果没有这个类就进行实例化
    if(!instance) return new Person(); 
    // 如果有了这个实例对象就直接返回
    return instance;
}
/*
	当第一次调用singleTon的时候，instance是null，就要执行new Person给instance赋值
	从此以后instance就是一个Person的实例了
*/
let p1 = new singleTon();

/*
	当第二次调用singleTon的时候，此时instance就是第一次new出来的实例，if条件就不会执行	了，直接返回第一次实例的地址
*/
let p2 = new singleTon();
console.log(p1 === p2) // true
```

问题：保护变量和保护构造函数

```js
/*
	单例设计模式升级版：采用闭包的形式保护变量和构造函数
*/
const Person = (function () {
        function Person() {
            this.name = 'mavis';
        }
        // 这个变量因为在一个不会被销毁的函数执行空间中，因此会一直存在
        let instance = null;
        // 全局变量接收的是这个函数
        return function singleTon() {
            if (!instance) {
                instance = new Person();
            }
            return instance;
        }
    })();
    let p1 = new Person();
    let p2 = new Person();
    console.log(p1 === p2); // true
```



###### 6.2 JS中的类

在类（class）的概念引入之前，js是通过原型对象来模拟实现类和类的继承的，直到ES6之后才出现类（class）的概念，但此处的类也只是基于JavaScript原型继承的语法糖。

1）ES6中类的声明：

constructor方法用来创建和初始化对象，而且一个类中有且只能有一个constructor方法，默认为`constructor() {}`。如果没有显式定义，类内部会自动给我们创建一个constructor()。

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
    sayHi() {
        console.log('hi~');
    }
}
let dog = new Animal('dog');
dog.sayHi(); // hi~
```

2）ES5中模拟创建类：

在ES5中用构造函数和原型对象来实现类和类的继承。

```JavaScript
function Animal(name) {
    this.name = name;
}
Animal.prototype.sayHi = function() {
    console.log('hi~');
}
let dog = new Animal('dog');
dog.sayHi(); // hi~
```

从上面两点可以看出，class中的constructor()方法就相当于Animal()构造函数，而在class中定义属性和方法就相当于直接在原型对象上定义属性和方法。

3）class的继承：

class使用`extends`关键字来实现继承。

```JavaScript
class Animal {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`hello~`);
  }
}
class Dog extends Animal {
  sleep() {
    console.log(`睡觉`);
  }
}
let wangcai = new Dog('旺财');
wangcai.sleep(); // 睡觉
wangcai.sayHi(); // hello~
```

* 但是如果在子类中定义了constructor()方法，必须先调用super()才能使用this，因为子类并没有this对象，而实继承父类的this对象，所有super必须在使用this关键字之前使用。

```JavaScript
class Animal {
     constructor(name) {
         this.name = name;
     }
     sayHi() {
         console.log(`hello, ${this.name}`);
     }
}

class Dog extends Animal {
    constructor(name, sound) {
        this.name = name;
        this.sound = sound;
    };
    bark() {
        console.log(this.sound);
    }
}
let wangcai = new Dog('旺财', '喵喵喵');
wangcai.bark(); // referenceError

class Dog extends Animal {
    constructor(name, sound) {
        super();
        this.name = name;
        this.sound = sound;
    };
    bark() {
        console.log(this.sound);
    }
}
let wangcai = new Dog('旺财', '喵喵喵');
wangcai.bark(); // 喵喵喵
```

super不仅可以调用父类的constructor函数，还可以调用父类上的方法。

```JavaScript
class Animal {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`hello~`);
  }
}

class Dog extends Animal {
  sleep() {
    super.sayHi();
  }
}

let wangcai = new Dog('旺财');
wangcai.sleep(); // hello~
```

4）静态方法(static)：

所有在类中定义的方法都会被实例继承，但是有时候我们并不想所有实例都能继承某个方法，这时候使用static关键字就能达到目的。在声明方法前加上static关键字，这个方法就不会被实例继承，而是只能通过类来调用，他被叫做静态方法。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`hello, ${this.name}`);
  }
  static bark() {
      console.log('喵喵喵');
  }
}
let dog = new Animal('dog');

dog.bark(); // TypeError
Animal.bark(); // 喵喵喵
```

静态方法虽然不能被实例继承，但是可以被子类继承，不过子类的实例仍然不能继承它。

```JavaScript
class Animal {
  static bark() {
      console.log('喵喵喵');
  }
}
class Dog extends Animal{

}
Dog.bark(); // 喵喵喵
let dog = new Dog();
dog.bark(); // TypeError
```

5）实例属性：

实例属性顾名思义，就是对象独有的方法/属性。

实例属性必须定义在类的constructor()方法里面。

```JavaScript
class Animal {
  constructor(name) {
    this.name = name; // 实例属性
  }
}
```

静态属性和原型属性必须在类的外面定义。

```JavaScript
Animal.age = 18; // “静态属性”
Animal.prototype.sex = 'male'; // 原型属性
```

静态属性就是属于class本身的属性，但是ES6中明确说明class只有静态方法，没有静态属性；原型属性就是位于原型链上的属性/方法。



###### 6.3 原型和原型链

1）*原型对象`prototype`：*JS规定，每一个构造函数都有一个prototype属性指向它的原型对象prototype。可以把哪些不变的方法直接定义在prototype对象上，这样所有的实例对象就可以共享这些方法。一般情况下，公共属性定义到构造函数里面，公共的方法放在构造函数的原型对象prototype上。

2）*对象原型*`__proto__`：每个对象实例都拥有一个属性就是对象原型`__proto__`，`__proto__`属性指向构造函数的prototype原型对象上。

3）constructor构造函数：原型对象`prototype`和对象原型`__proto__`都有一个属性constructor，我们也称之为构造函数，因为它指回构造函数本身。

4）构造函数、实例、原型对象三者之间的关系：

[![O8B7Q0.png](https://s1.ax1x.com/2022/05/09/O8B7Q0.png)](https://imgtu.com/i/O8B7Q0)

5）原型链：一个对象往往可以通过不断使用对象原型`__proto__`追溯到最根源的原型对象上，这个原型对象就是null，这种通过原型对象和对象原型一层层向上查找的关系就被称为原型链。

[![O8BXo4.png](https://s1.ax1x.com/2022/05/09/O8BXo4.png)](https://imgtu.com/i/O8BXo4)

###### 6.4 new运算符的实现机制

new实例化函数的过程：

1、创建一个空对象；

2、将这个空对象的对象原型`__proto__`指向构造函数的原型对象prototype；

3、执行构造函数，并且将构造函数中的this指向这个新对象；

4、若构造函数中返回值是this或返回值是基本数据类型或无返回值，则返回这个新的实例对象；若返回值是引用类型，则返回这个引用类型。

```js
/* 自己实现一个new */
function Person(uname) {
    this.uname = uname;
}

function newOperator(constructor, arguments) {
    // 1、创建一个新的空对象
    const obj = {};
    // 2、将这个对象的对象原型__proto__指向构造函数的原型对象prototype
    obj.__proto__ = constructor.prototype;
    // 3、执行这个构造函数，在执行的过程中将构造函数中的this指向这个实例对象
    Person.call(obj, arguments);
    // 4、返回这个实例对象
    return obj;
}

let p = newOperator(Person, 'mavis');
console.log(p); // Person {uname: 'mavis'}
```



###### 6.5 call/apply/bind

JS专门提供了一些函数方法来帮助大家更加优雅地处理函数内部的this指向问题，常用的有`call()`，`apply()`和`bind()`三种。

1）call方法：调用一个函数，可以改变函数的this指向。

```js
fn.call(thisArg, arg1, arg2...);
```

`thisArg`：所调用函数的目标this指向；

`arg1,arg2`：传递的其他参数。

2）apply方法：调用一个函数，可以改变函数的this指向。

```JavaScript
fn.call(thisArg, [argsArray]);
```

`thisArg`：所调用函数的目标this指向；

`arg1,arg2`：传递的其他参数，必须包含在数组里面。

3）bind方法：不会调用函数，但是能够改变函数内部的this指向。

```JavaScript
fn.bind(thisArg, arg1, arg2...);
```

`thisArg`：所调用函数的目标this指向；

`arg1,arg2`：传递的其他参数。

返回由指定的this值和初始化参数改造的原函数拷贝，返回了一个新的函数。

如果有的函数不需要立即调用，但又想改变这个函数内部的this指向，此时就用bind。

4）三者的主要应用场景：

* call经常用作继承；
* apply经常跟数组有关系，比如借助数学对象实现数组最大值和最小值；
* bind不调用函数，但是能够改变this指向，比如改变定时器内部的this指向。

手写call:

```js
Function.prototype.myCall = function (ctx, ...args) {
     	var ctx = ctx || window;
    	// 1、将方法挂载到传入的上下文ctx中
        ctx.fn = this;
    	// 2、将挂载以后的方法调用
        ctx.fn(...args);
    	// 3、将添加的这个属性删除
    	delete ctx.fn;
    }

    function show() {
        console.log(this);
    }

    show.myCall({ name: 'maivs' }, 'hello');
```

手写apply：

```JavaScript
Function.prototype.myApply = function (ctx, args = []) {
    	var ctx = ctx || window;
    	// 判断，如果传入的参数不是数组则报错
        if (args && !(args instanceof Array)) {
            throw ('传入的参数不是数组！')
        }
        // 1、将方法挂载到传入的上下文ctx中
        ctx.fn = this;
    	// 2、将挂载以后的方法调用
        ctx.fn(...args);
    	// 3、将添加的这个属性删除
    	delete ctx.fn;
    }

    function show(...args) {
        console.log(this);
        console.log(args);
    }

    show.myApply({ name: 'maivs' }, ['hello', 'hi']);
```

手写bind：

```JavaScript
Function.prototype.myBind = function (ctx, ...args1) {
        let that = this;
        return function (...args2) {
           // 1、将方法挂载到传入的上下文ctx中
        	ctx.fn = that;
    		// 2、将挂载以后的方法调用
        	ctx.fn(...args1.concat(args2));
    		// 3、将添加的这个属性删除
    		delete ctx.fn;
        }
    }

    function show(...args) {
        console.log(this);
        console.log(args);
    }

    let foo = show.myBind({ name: 'maivs' }, 'hello', 'hi');
    foo('haha');
```



###### 6.6 constructor构造函数模式 

*构造函数模式：*构造函数用于创建特定类型的对象，不仅声明了使用的对象，构造函数还可以接收参数以便第一次创建对象的时候设置对象的成员值。

在JavaScript里，构造函数通常是认为用来实现实例的，JavaScript中没有类的概念，但是有特殊的构造函数。通过new关键字来调用自定义的构造函数，在构造函数内部，this关键字指向的是新创建的实例对象。

###### 6.7 JS中this关键字的综合梳理

1）this的4种绑定规则：

* 默认绑定：当一个函数没有明确的调用对象时，将对函数的this使用默认绑定，this指向window。严格模式下（`use strict`），不能将全局对象用于默认绑定。

```js
function eat() {
    console.log(this);
}
eat(); // window
```

* 隐式绑定：在一个对象的方法中出现，则this指向这个对象

```js
let person = {
    name: 'mavis',
    sayHi: function() {
        console.log('我的名字是' + this.name);
    }
}
person.sayHi(); // person
```

* 显式绑定：采用`call()`和`apply()`，通过传入一个对象，将this绑定到该对象上。

```js
function test() {
        console.log(this);
    }
    var obj = {
        name: 'mavis'
    }
test.call(obj); // { name: 'mavis'}
```

* new绑定：当使用new关键字调用构造函数时，函数中的this一定指向所创建的新对象。

任何函数都可能被用作构造函数，当函数被进行new操作时，会执行以下操作：

```text
1、 创建一个空的对象；
2、 将这个新的对象的对象原型__proto__指向构造函数的原型对象prototype上；
3、 执行构造函数，同时将构造函数的this指向这个新的对象上；
4、返回这个对象；
```

```js
function Test() {
        console.log(this);
    }
   
const t = new Test();
console.log(t); 
```

2）箭头函数中的this指向：

箭头函数中的this指向是在创建它时最近一层作用域中的this指向（箭头函数不绑定this，会捕获其所在上下文中的this值作为自己的this值，任何方法都改变不了其this指向）。这里的重点有两个：

```text
1、创建箭头函数的时候就已经确定了它的this指向；
2、箭头函数内的this指向它最近一层作用域中的this。
```

所以要知道箭头函数的this指向就先要知道它最近一层作用域中的this指向。

```js
// 最近一层作用域的this指向window，因此此处的箭头函数中的this指向window
let arr = [1, 2 , 3];
    arr.forEach( item => {
        console.log(this);  // window
    })

// 最近一层作用域的this指向对象obj，因此此处箭头函数中的this指向obj对象；
let obj = {
        sum: function () {
            let arr = [1, 2, 3];
            arr.forEach( item => {
                console.log(this); // obj
            })
        }
    }
obj.sum();
```

**箭头函数中的注意点：**

* 在箭头函数中，`bind()`、`apply()`和`call()`只能传递参数，不能修改箭头函数中的this指向；

```JavaScript
let fn = func => {
        console.log(this);
	}
let obj = {
    	name: 'mavis'
	}
fn.call(obj);  // window
```

* 箭头函数没有原型；

```javascript
let fn = func => {
        console.log(this);
    }
console.log(fn.prototype); // undefined
```

* 箭头函数不能绑定`arguments`，取而代之用rest参数`...`解决；

```javascript
let fn = (arguments) => {
        console.log(arguments);
    }
fn(1, 2, 3);  // 1
```

```JavaScript
let fn = (...args) => {
        console.log(args);
    }
fn(1, 2, 3);  // [1, 2, 3]
```

* 箭头函数是匿名函数，不能作为构造函数，不能使用new；

```javascript
let fn = (...args) => {
        console.log(args);
    }
new fn();  // TypeError: fn is not a constructor
```

* 箭头函数不可以使用`yield`命令，因此箭头函数不能用作Generator函数。



######  6.8 JS中四大数据类型检测方案

1）typeof：返回的结果都是字符串。“number”/“string”/“boolean”/“undefined”/“symbol”/“object”

```js
console.log(typeof 1);//number
console.log(typeof '你好');//string
console.log(typeof true);//boolean
console.log(typeof undefined);//undefined
console.log(typeof null);//object
console.log(typeof function () { });//function
console.log(typeof {});//object
console.log(typeof []);//object
console.log(typeof /\d/);//object
```

`typeof`的局限性：

```js
a. typeof null => “object”  null不是对象，它是空对象的指针
b. 检测数据或者正则等特殊的对象时，返回的结果都是“object”，所以无法基于typeof判断到底是数据还是正则。
```

2）instanceof：instanceof运算符用来判断一个构造函数的prototype属性指向的对象是否存在另外一个要检测对象的原型链上。null和undefined会报错。(检测某个实例是否属于这个类)

```js
console.log(new Number(1) instanceof Number);//true
console.log(new String('你好') instanceof String);//true
console.log(new Boolean(true) instanceof Boolean);//true
console.log(function () { } instanceof Function);//true
console.log({} instanceof Object);//true
console.log([] instanceof Array);//true
console.log(/\d/ instanceof RegExp);//true
```

3）constructor：表示创建实例的构造函数的引用

```js
console.log((1).constructor);//function Number()
console.log(('你好').constructor);//function String()
console.log((true).constructor);//function Boolean()
console.log((function () { }).constructor );//function Function()
console.log(([]).constructor);//function Array()
console.log((/\d/).constructor);//function RegExp()
```

4）Object.prototype.toString.call：不是用来转换为字符串的，而是返回当前实例所属类的信息。

```js
console.log(Object.prototype.toString.call(123).slice(8, - 1));//Number
console.log(Object.prototype.toString.call(123));//[object Number]
console.log(Object.prototype.toString.call('你好'));//[object String]
console.log(Object.prototype.toString.call(undefined));//[object Undefined]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call(function(){}));//[object Function]
console.log(Object.prototype.toString.call([]));//[object Array]
console.log(Object.prototype.toString.call({}));//[object Object]
console.log(Object.prototype.toString.call(/\d/));//[object RegExp]
```

这种方式基本上没有什么局限性，是检测数据类型最准确的方式。



######   6.9 JS中的六大继承方案

1）原型链继承：将父类的实例指向子类的原型对象。

```js
function Person(uname) {
    this.uname = uname;
}
function Man() {
    Man.prototype = new Person('mavis');
}
let m1 = new Man();
console.log(m1);
```

不难发现，我们将Man的原型对象指向了父类Person的实例，因此Man继承自Person。但这并不是最理想的继承方式：虽然Man继承了Person，但他的原型对象其实是Person.prototype，**子类在实例化过程中并不能向父类传递参数**。所以这种方式并未实现真正的继承。

2）构造函数继承：通过`call`或`apply`方法将父类构造函数中的this指向子类构造函数

```js
function Person(uname) {
        this.uname = uname;
    }
function Man(uname) {
        Person.call(this, uname)
    }
let m1 = new Man('mavis');
console.log(m1);
```

构造函数继承的核心思想就是通过`call`或`apply`改变this的指向达到继承的目的。这种方法看似实现了完美的继承，实则不然：

```js
console.log(m1.__proto__ === Person.prototype);  // false
console.log(m1.__proto__ === Man.prototype);   //true
console.log(Man.__proto__ === Person.prototype);  // false
console.log(Man.__proto__ === Function.prototype);  // true 
console.log(Man.prototype.__proto__ === Person.prototype);  // false
```

子类的原型对象并不是指向父类的：并没有显式地为Man的原型对象指向Person实例。因此，通过构造函数继承得到的子类的原型还是指向自身。（原型链断裂问题）

3）组合式继承：结合原型链继承和构造函数继承的优点

```js
function Person(uname) {
        this.uname = uname;
    }
function Man(uname) {
        Person.call(this, uname)
    }
Man.prototype = new Person();
Man.prototype.constructor = Man;
let m1 = new Man('mavis');
console.log(m1);
```

组合继承解决了构造函数继承中的原型链断裂的问题：

```js
console.log(Man.prototype.__proto__ === Person.prototype);  // true
```

4）原型式继承（实例继承）：

不同于原型链继承，原型式继承通过调用`Object.create()`方法实现继承。

`Object.create()`方法创建一个新的对象，使用现有的对象来提供新创建对象的`__proto__`。

语法：`Object.create(proto)`，其中 'proto'指的是新创建对象的原型对象。

```js
function Person(uname) {
        this.uname = uname;
    }
let p = new Person('mavis');
let p1 = Object.create(p);
console.log(p1.uname);  // mavis
```

p1中的属性来自于父类的原型对象中，并不是真正的属于自己。这通常会导致原型指针混乱而造成this指向不明的问题。

5）寄生组合式继承：

在组合式继承中，将子类的原型对象指向父类的实例时，会导致父类的构造函数被调用两次（第一次在子类构造函数中，第二次在new Person()时）。结合组合式继承原型链清晰的优点和原型式继承的不需要调用父类构造函数的优点，再次组合：

```js
function Person(uname) {
        this.uname = uname;
    }
function Man(uname) {
        Person.call(this, uname);
    }
Man.prototype = Object.create(Person.prototype);
Man.prototype.constructor = Man;

let m = new Man('mavis');
console.log(m);
```

寄生组合式继承是目前应用最为广泛的继承方式。

6）ES6中的继承：

使用`extends`关键字实现从父类继承，但他只是语法糖，其本质仍然是以上组合方式的一种。

```js
class Person {
        constructor(uname) {
            this.uname = uname;
        }
    }
class Man extends Person {

    }
let p = new Man('mavis');
console.log(p);
```



###### 6.10 深浅拷贝

* 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

* 深拷贝会创造另一个一模一样的对象，新对象跟旧对象不共享内存，修改新对象不会改变原对象。

```text
  某参数需要同时在两个地方用到，但是一个地方需要用到的是数组，另一个地方需要用到的是字符串格式。这时候这两个地方就产生了冲突。后来看到了深拷贝的帖子。因为深拷贝是在计算机中开辟一块新的内存地址用来存放拷贝后的对象，如果原对象发生了变化，复制的对象并不会发生变化，因此我在原对象采用了数组的形式，拷贝后的对象再转换成字符串的形式，这样既达到了目的，也避免了冲突的发生。
```

  深拷贝的实现方式：

  1）用`JSON.stringify()`将对象转成字符串，再用`JSON.parse()`把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。缺点：这种方法虽然可以实现数组或者对象深拷贝，但是不能处理函数和正则表达式。

  2）`lodash`函数库实现深拷贝：`lodash`提供了`lodash.cloneDeep()`的方法来实现深拷贝。

  3）通过递归实现深拷贝：通过递归，将每一层的对象都克隆到。

  ```js
  function deepClone(obj) {
      // 过滤掉几种特殊情况
      if(obj === null) return null;
      if(typeof obj !== 'object') return obj;
      if(obj instanceof RegExp) {
          return new RegExp(obj);
      }
      if(obj instanceof Date) {
          return new Date(obj);
      }
      
      // 不直接使用new Object()创建空对象的目的是为了克隆的结果和之前保持相同的所属类
      let newObj = new obj.constructor;
      for (let key in obj) {
          if(obj.hasOwnProperty(key)) {
              newObj[key] = deepClone(obj[key])
          }
      }
      return newObj;
  }
  ```



###### 6.11 防抖与节流

**1、函数防抖：**

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新开始计时。

```js
function debounce(fn, timeout) {
    let timer = null;
    return function() {
            	if(timer) {
                	clearTimeout(timer);
            	}
            	timer = setTimeout(() => {
                	fn.call(this);
            	}, timeout);
        	}
}
```

防抖的应用场景：

* 给按钮添加防抖，防止表单多次提交；
* 对输入框连续输入进行Ajax验证时，用函数防抖能有效减少请求次数；
* 判断scroll是否滑到底部，采用 滚动事件+函数防抖

**2、函数节流：**

规定在一段时间内只触发一次函数，如果这段时间内多次触发函数，则只有一次有效。

```JavaScript
function throttle(fn, delay) {
    let lastTime;
    let timer = null;
    return function() {
            let curTime = new Date().getTime();
            if(lastTime && curTime < lastTime + delay) {
                clearTimeout(timer);
                timer = setTimeot(() => {
                    lastTime = curTime;
                    fn.call(this);
                }, delay)
            } else {
                lastTime = curTime;
                fn();
            }
        }
}
```

节流的应用场景：

* 游戏中的刷新率；
* 总的来说，适合大量事件按照时间做平均分配触发。



#### 7、DOM/BOM及事件处理机制

------

###### 7.1 DOM/BOM的核心操作

1）DOM(文档对象模型，Document Object Model )：W3C组织推荐的处理可扩展标记语言(HTML或XML)的标准编程接口。

* DOM树：

  * 文档：一个HTML页面就是一个文档，DOM中使用document表示；
  * 元素：页面中所有的标签都是元素，DOM中使用element表示；
  * 节点：网页中所有的内容都是节点，DOM中使用node表示。

* 获取元素：

  * 根据ID获取：`document.getElementById('app');`
  * 根据标签名获取：`document.getElementByTagName('li');`
  * 根据HTML5新增的元素获取：

  ```js
  根据类名获取： document.getElementByClassName('app');
  返回指定选择器的第一个元素对象： document.querySelector('#box');
  返回指定选择器的所有集合： document.querySelectorAll('.box');
```

  * 获取body标签：`document.body;`
  * 获取HTML元素：`document.documentElement;`
  * 改变元素内容：`document.innerHtml;`

* 事件三要素：

  * 事件源：事件被触发的对象。比如说一个按钮；
  * 事件类型：什么事件？如何触发？比如说鼠标点击；
  * 事件处理程序：通过一个函数赋值的方式完成。

```js
  var btn = document.getElementById('btn');
  btn.onclick = function() {
      console.log('点击了');
  }
```

* 操作元素：

JavaScript的DOM操作可以改变网页内容、结构和样式，可以利用DOM操作元素来改变元素里面的内容、属性等。

```js
element.innerText; // 会去除html标签，同时也会去除空格和换行
element.innerHTML; // 不会去除HTML标签、空格和换行
```

* 创建元素：

  * document.write()：直接将元素写入页面的内容流，文档流执行完毕，会导致页面重绘；
  * document.innerHTML：将内容写入某个DOM节点，不会导致重绘，创建多个元素效率更高（不要采取拼接字符串，要以数组形式拼接）；
  * document.createElement()：创建多个元素效率稍低，但结构清晰。

  总结：不同浏览器下，innerHTML效率（采用数组形式）要比createElement高。

* addEventListener事件监听注册事件：

eventTarget.addEventListener()方法将指定的监听器注册到eventTarget()（目标对象）上，当对该对象触发指定事件时，就会执行事件处理函数。

```text
eventTarget.addEventListener(type, listener[, useCapture]) {}
```

该方法接受三个参数：

type：事件类型字符串，比如click，mouseover；

listener：事件处理函数，事件发生时，会调用监听该函数；

useCapture：可选参数，是一个布尔值。为true时表示处于捕获阶段；为false时表示处于冒泡阶段

```JS
btn.addEventListener('click', function() {
    console.log('hihi');
})
```

2）BOM（浏览器对象模型， Browser Object Model）：

BOM主要包含五个基础对象：

```text
1、window：表示文档实例
2、location：加载导航的信息和常用导航功能实例
3、navigator：客户端标识和信息的对象实例
4、screen：客户端显示器信息
5、history：当前窗口建立以来的导航历史记录
```

window对象是浏览器的顶级对象，它具有双重角色：

* 它是JS访问浏览器窗口的一个接口；
* 它是一个全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法。

窗口加载事件：当文档内容完全加载完成后会触发该事件（包括img，脚本，css等）

```JavaScript
window.onload = function() {}
```

window.onload() 与 $(document).ready()的区别：

```text
1、window.onload() 必须等待网页全部加载完毕（包括图像脚本等），然后再执行JS代码；
2、$(document).ready() 只需等待网页中的DOM结构加载完毕即可执行JS代码。
```

定时器：

```text
setTimeout：延时时间到了，就调用这个回调函数，只调用一次。
setInterval：每隔这个时间，就调用这个回调函数，重复调用多次。
```



###### 7.2 事件对象

* 当触发一个事件以后，会存在对该事件的一些描述信息，每一个事件都会有一个对应的对象来描述这些信息，这个对象就被称作事件对象。
* 浏览器给了我们一个黑盒子叫做`window.event`，就是对事件信息的所有描述

```js
var box = document.querySelector('.box');
box.onclick = function(e) {
    // 兼容写法
    e = e || window.event;
    console.log(e);
}
```

上面的这个e就是事件对象。



###### 7.3 拖拽及拖拽插件封装

方法1：并不是所有的元素都是可以拖动的，需要在元素中加上`draggable="true"`，定义了这个属性以后就可以注册事件了。

```html
<div draggable = "true"> </div>
```

|        | 开始   | dragstart |          | 进入时 | dragenter |
| :----: | ------ | --------- | -------- | ------ | --------- |
| 拖动时 | 进行中 | drag      | 进入区域 | 进入后 | dragover  |
|        | 结束   | dragend   |          | 离开   | dragleave |
|        |        |           |          | 放置   | drop      |

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    body {
        margin: 0;
        padding: 0;
        position: relative;
    }

    .box {
        position: fixed;
        width: 200px;
        height: 200px;
        background-color: lightpink;
    }

    .banner {
        display: flex;
        position: fixed;
        width: 230px;
        height: 230px;
        left: 300px;
        background-color: rgb(172, 194, 75);
        justify-content: center;
        align-items: center;
    }
</style>

<body>
        <div class="box" draggable="true"></div>
        <div class="banner"></div>
</body>
<script>

    var box = document.querySelector('box');
    var banner = document.querySelector('.banner');

    document.addEventListener('drag', function (e) {
        e.target.style.border = "3px solid red";
    })
    document.addEventListener('dragend', function (e) {
        e.target.style.border = "none";
        banner.style.border = "none";
    })
    banner.addEventListener('dragenter', function (e) {
        if (banner.firstChild) {
            banner.removeChild(banner.firstChild);
        }
        e.target.style.border = "3px dashed blue";
    })
    banner.addEventListener('dragover', function (e) {
        e.preventDefault();
    })
    banner.addEventListener('drop', function (e) {
        e.preventDefault();
        e.target.appendChild(document.querySelector('.box'));
    })

</script>

</html>
```



###### 7.4 发布订阅设计模式

实现发布订阅需要有几个步骤：

```text
1、需要知道谁是发布者；
2、需要一个缓存列表用来绑定每个监听器它所对应的回调函数，用来通知订阅者；
3、当事件触发时（状态发生变化的时候），发布者遍历这个缓存列表，依次执行里面的订阅者回调函数。
```

实现一个简单的发布订阅：

```js
    var Event = (function () {
        // 缓存列表
        var List = [];
        // 订阅者
        var watcher = function (key, fn) {
            if (!this.List[key]) {
                this.List[key] = [];
            }
            this.List[key].push(fn);
        };
        // 消息发布
        var dep = function () {
            // 将对应的key取出
            var key = Array.prototype.shift.call(arguments);
            var fns = this.List[key];
            if (!fns || fns.length === 0) {
                return;
            }
            for (var i = 0, fn; fn = fns[i]; i++) {
                fn(...arguments);
            }
        };
        // 取消订阅
        var remove = function (key, fn) {
            if (!this.list[key]) return;
            this.list[key] = this.list[key].filter(item => {
                return item !== fn;
            })
        }
        return {
            List,
            watcher,
            dep,
            remove
        }
    })();
```



###### 7.5 深度解剖JQuery源码



###### 7.6 事件传播机制和事件代理（委托）

1）事件传播机制：

DOM事件流：事件流描述的是从页面中接收事件的顺序。

事件发生时会在元素节点之间按照特定的顺序传播，这个传播的过程即DOM事件流。

[![O8Bozq.png](https://s1.ax1x.com/2022/05/09/O8Bozq.png)](https://imgtu.com/i/O8Bozq)

DOM事件流分为3个阶段：

```text
1、捕获阶段；
2、当前事件阶段；
3、冒泡阶段。
```

阻止事件冒泡的方式：

利用事件对象中的`stopPropagation()`方法

```js
e.stopPropagation();
```

2）事件委托的原理：

不是给每个子节点单独设置事件监听器，而是在其父节点上设置事件监听器，然后利用冒泡的原理影响设置每个子节点。

事件委托的作用：只操作了一次DOM，提高了程序的性能。

ex：为下面代码绑定事件：

```html
<ul id="fruit">
	<li>苹果</li>
	<li>橘子</li>
	<li>葡萄</li>
	<li>橙子</li>
</ul>
```

第一种：利用循环对每一个对象的遍历，给每一个子元素绑定事件

```js
var lis=document.querySelectorAll("li");   //找到页面中所有的li标记
    for(var i=0;i<lis.length;i++){
        console.log(lis[i]);         //显示lis对象中的每一个元素
        lis[i].onmouseover=function(){
        this.style.backgroundColor="#3385ff";
		}
	}
```

第一种方法的缺点：循环绑定过程中，在元素的事件代码里不能得到正确的循环变量值。

事件代码会在事件发生时执行，for循环会自动执行，所以在for循环执行结束后，事件代码也不一定能执行，事件代码执行一定是在for循环以后。

第二种：事件委托

```js
fruit.onmouseover=function(){
    //event.target表示真正触发事件的那一个子元素
	if(event.target.tagName.toLowerCase()==="li"){	
        event.target.style.backgroundColor="#3385ff";	
	}
}
```



###### 7.7 DOM2级事件的核心运行机制

1）事件委托：见7.6

2）事件的监听：

`addEventListener():`为DOM对象添加事件监听器；

`removeEventListener():`为DO没对象移除已经添加的事件监听器；

```JS
var fn=function(){
  this.style.borderRadius="30px";
}
box.addEventListener("click",fn);   //为box元素添加事件监听器，监听到click事件执行f1函数

btn.addEventListener("click",function(){
  box.removeEventListener("click",fn);    //移除事件需要在添加时为事件起一个名字
})
```

3）事件传播：见上7.6



###### 7.8 移动端Touch/Gesture事件及封装处理



###### 7.9 浏览器底层渲染机制和DOM的重排重绘

1）浏览器的渲染机制：

```text
1、浏览器将获取到的HTML文档解析成DOM树；
2、处理CSS标记，构成CSSOM（CSS Object Model）层叠样式表模型；
3、将DOM树和CSSOM层叠样式表模型合并为渲染树（render tree），代表一系列将要被渲染的对象；
4、渲染树的每个元素包含的内容是计算过的，称之为布局layout，浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有元素；
5、将渲染树的各个节点绘制到屏幕上，这一步被称之为绘制painting。
```

2）DOM的重排（reflow）和重绘（repaint）：

* 重排（回流）：当render tree中的一些元素的结构或者尺寸等发生改变时，浏览器会重新渲染部分或者全部文档，这个过程就叫做回流（重排）。
  * 会导致重排的操作：
    * 页面首次渲染；
    * 浏览器窗口发生变化；
    * 元素的尺寸位置发生变化；
    * 添加或者删除DOM节点；
    * 激活CSS伪类。
* 重绘：当页面中的元素样式改变不影响它在文档流中的位置，浏览器会将新样式重新绘制在屏幕上的过程叫做重绘。
  * 会导致重绘的操作：
    * 当`visibility`、背景色等属性改变时，会触发重绘；
    * 重排一定导致重绘，重绘不一定导致重排。

* 减少重排与重绘的方法：

  * 不在布局信息改变时做DOM查询；
  * 不要一条一条的修改DOM样式，使用className一次性改变属性；
  * 对于一个元素进行复杂操作时，先隐藏，操作完再展示；
  * 不要使用table布局，一个小改动会导致table重新布局；

  

###### 7.10 DIALOG模态框组件的封装





#### 8、ES6/ES7的核心知识

------

###### 8.1 let、const和var的区别

1）var：

* var用于声明变量
* 存在变量提升机制
* 如果变量不声明直接赋值，会被当作全局变量，即全局对象window的一个属性。

2）let：

* 块级作用域
* 不存在变量提升
* 不影响作用域链
* 变量不能重复声明。

3）const：

* 块级作用域
* 一定要赋初始值
* 常量的值一经定义不能修改
* 对于数组和对象，可以修改里面具体属性的值，只要不影响其地址指向即可。



###### 8.2 箭头函数

箭头函数中的this指向：

箭头函数中的this指向是在创建它时最近一层作用域中的this指向（箭头函数不绑定this，会捕获其所在上下文中的this值作为自己的this值，任何方法都改变不了其this指向）。这里的重点有两个：

```text
1、创建箭头函数的时候就已经确定了它的this指向；
2、箭头函数内的this指向它最近一层作用域中的this。
```

所以要知道箭头函数的this指向就先要知道它最近一层作用域中的this指向。

```js
// 最近一层作用域的this指向window，因此此处的箭头函数中的this指向window
let arr = [1, 2 , 3];
    arr.forEach( item => {
        console.log(this);  // window
    })

// 最近一层作用域的this指向对象obj，因此此处箭头函数中的this指向obj对象；
let obj = {
        sum: function () {
            let arr = [1, 2, 3];
            arr.forEach( item => {
                console.log(this); // obj
            })
        }
    }
obj.sum();
```

**箭头函数中的注意点：**

* 在箭头函数中，`bind()`、`apply()`和`call()`只能传递参数，不能修改箭头函数中的this指向；

```JavaScript
let fn = func => {
        console.log(this);
	}
let obj = {
    	name: 'mavis'
	}
fn.call(obj);  // window
```

* 箭头函数没有原型；

```javascript
let fn = func => {
        console.log(this);
    }
console.log(fn.prototype); // undefined
```

* 箭头函数不能绑定`arguments`，取而代之用rest参数`...`解决；

```javascript
let fn = (arguments) => {
        console.log(arguments);
    }
fn(1, 2, 3);  // 1
```

```JavaScript
let fn = (...args) => {
        console.log(args);
    }
fn(1, 2, 3);  // [1, 2, 3]
```

* 箭头函数是匿名函数，不能作为构造函数，不能使用new；

```javascript
let fn = (...args) => {
        console.log(args);
    }
new fn();  // TypeError: fn is not a constructor
```

* 箭头函数不可以使用`yield`命令，因此箭头函数不能用作Generator函数。

箭头函数的简写：

* 省略小括号：当形参有且只有一个的时候可以省略小括号
* 省略大括号：当代码体只有一条语句的时候，此时 return 必须省略，而且语句的执行结果就是函数的返回值。

```js
let pow = n => n * n;
```



###### 8.3 解构赋值和拓展运算符

1）解构赋值：

ES6允许按照一定的模式对数组和对象提取值，对变量进行赋值，这种操作被称为解构赋值。

* 数组的解构：

[![O8BLeU.png](https://s1.ax1x.com/2022/05/09/O8BLeU.png)](https://imgtu.com/i/O8BLeU)


* 对象的解构：

[![O8BxY9.png](https://s1.ax1x.com/2022/05/09/O8BxY9.png)](https://imgtu.com/i/O8BxY9)


2）拓展运算符：

拓展运算符`...`能够将数组转化为用逗号分隔的参数序列

```js
const tfboys = ['yyqx', 'wy', 'wjk'];
console.log(...tfboys); // 'yyqx','wy','wjk'
```

拓展运算符的运用：

* 数组合并：

  ```js
  const a = [1, 2, 3];
  const b = [4, 5, 6];
  const c = [...a, ...b];
  console.log(a, b); // [1, 2, 3, 4, 5, 6]
```

* 数组克隆：

```js
const a = [1, 2, 3];
const b = [...a];
console.log(b); // [1, 2, 3]
```

* 将伪数组转化为真正的数组：

```js
const divs = document.querySelector('div');
const divArr = [...divs];
console.log(divArr);
```



###### 8.4 Set/Map数据结构

1）Set数据结构：

ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。

Set本身是一个构造函数，用来生成Set数据结构：

```js
const s = new Set();
```

Set函数可以接收一个数组作为参数，用来初始化：

```js
const set = new Set([1, 2, 3, 4, 4]);
console.log(set); //Set(4) {1, 2, 3, 4}
```

利用Set数据结构可以进行数组去重，往Set数据结构中存储重复的值时，Set会将重复的值过滤掉。

size属性：Set数据结构的长度

```js
const set = new Set([1, 3, 4]);
console.log(set.size); //  3
```

*Set数据结构的实例方法：*

* add(value)：添加某个值，返回Set数据结构本身；可以链式调用；
* delete(value)：删除某个值，返回一个布尔值，表示是否删除成功；
* has(value)：返回一个布尔值，表示该值是否为Set的成员；
* clear()：清楚所有成员，没有返回值；

*遍历Set数据结构：*

Set数据结构的实例与数组一样也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。

```js
const set = new Set([1 ,3 ,5]);
set.forEach(item => console.log(item)); //
```

2）Map数据结构：

Map数据结构保存键值对，任何值都可以作为一个键或者一个值。

Map本身是一个构造函数，用来生成Map数据结构：

```js
const map = new Map();
```

属性：size   返回Map数据结构中键值对的数量

```js
const map = new Map([['name', 'mavis'], ['age', 18]]);
console.log(map.size); // 2
```

*Map数据结构的实例方法：*

* set(key, value)：给Map设置键名key和键值value，返回Map数据结构；如果key已有值，则键值更新，可以链式调用；
* get(key)：读取key对应的键值，如果找不到就返回undefined；
* clear()：清除所有成员，没有返回值；
* delete(key)：删除指定的键，返回布尔值，表示是否删除成功；
* has(key)：返回布尔值，判断Map实例是否包含键对应的值。

*遍历Map数据结构：*

Map数据结构也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。

```js
const map = new Map([['name', 'mavis'], ['age', 18]]);
map.forEach(item => console.log(item)); // 'mavis' , 18
```

从上面可以看到，forEach遍历的是值。

*Map和object的区别：*

* obj只能用字符串、数字或者Symbol等简单数据类型当作键，而map的键可以是任意数据类型；
* Map可以直接拿到长度，而obj不行；
* map实现了迭代器，可用for...of遍历，而obj不行；
* map不存在同名碰撞问题，每个对象都是单独的一块内存地址；
* 填入map的元素可以使用展开运算符展开，而obj不行。



###### 8.5 Promise设计模式

1）promise对象：

promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。

promise函数本身是同步的，其then、catch和finally方法是异步的。

* Promise有三种状态：
  * pending[待定]：初始状态
  * fulfilled[实现]：操作成功
  * rejected[拒绝]：操作失败

```js
var flag = false;
    var promise = new Promise((resolve, reject) => {
        if (flag) {
            resolve('操作成功！');
        } else {
            reject('操作失败！');
        }
    });
    promise.then(res => {
        console.log(res); // 成功
    }).catch(err => {
        console.log(err); // 失败
    })
```

 当Promise状态发生改变时，就会触发then()里的响应函数处理后续步骤。

状态改变只有两种可能：从pending变为fulfilled；从pending变为rejected。

```text
Promise的缺点：
1、无法取消，一旦新建就会立即执行，无法中途取消；
2、不设置回调函数的情况下，promise内部抛出的错误不会反映到外部；
3、当处于pending状态时，无法得知目前进展到哪一个阶段，刚开始还是快结束。
```

2）Promise.all：

可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

```js
let p1 = new Promise((resolve, reject) => {
        resolve('成功了！');
    });
    let p2 = new Promise((resolve, reject) => {
        resolve('success');
    });
    let p3 = Promise.reject('失败了');

    Promise.all([p1, p2]).then(res => {
        console.log(res);  // ["成功了！", "success"]
    }).catch(err => {
        console.log(err);
    });

    Promise.all([p1, p2, p3]).t hen(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);  // 失败了
    });
```

手写promise.all：

```JavaScript
Promise.all = function(promiseArr) {
    let index = 0, result = []
    return new Promise((resolve, reject) => {
        promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(val => {
                index++
                result[i] = val
                if (index === promiseArr.length) {
                    resolve(result)
                }
            }, err => {
                reject(err)
            })
        })
    })
}

```

3）Promise.race：

将promise.race传入的数组中最先执行完成的一个promise中的的参数返回。即哪个结果获得的快就返回哪个结果，不管结果本身时成功状态还是失败状态。

```js
let p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('成功了！');
        }, 1000);
    });
    let p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('失败了！');
        }, 500);
    });

    Promise.race([p1, p2]).then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    });
```

手写promise.race：

```JavaScript
Promise.race = function(promiseArr) {
    return new Promise((resolve, reject) => {
        promiseArr.forEach(p => {
            Promise.resolve(p).then(val => {
                resolve(val)
            }, err => {
                rejecte(err)
            })
        })
    })
}
```



###### 8.6 async/await及实现原理

  async/await是ES7提出的基于Promise的异步编程的终极解决方案。

async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象。

await也是一个修饰符，只能放在async定义的函数内，可以理解为**等待**。

await修饰的如果是Promise对象，可以获取Promise中返回内容（resolve或reject的参数），且取到值之后语句才会往下执行。

习题一：

```js
async function async1() {
    console.log('async1 start');
    Promise.resolve(async2()).then(() => {
                console.log('async1 end');
        })
}
async function async2() {
     console.log('async2');
Promise.resolve(async3()).then(() => {
                console.log(123);
        })
}
async function async3() {
     console.log('async3');
Promise.resolve(async4()).then(() => {
                console.log(456);
        })
}
async function async4() {
    await console.log('async4');
	console.log(789)
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

习题二：

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
     console.log('async2');
	await async3()
	console.log(123)
}
async function async3() {
     console.log('async3');
	await async4()
	console.log(456)
}
async function async4() {
    await console.log('async4');
	console.log(789)
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

习题三：

```js
async function async1() {
    console.log('async1 start');
    Promise.resolve(async2()).then(() => {
                console.log('async1 end');
        })
}
async function async2() {
     console.log('async2');
Promise.resolve(async3()).then(() => {
                console.log(123);
        })
}
async function async3() {
     console.log('async3');
Promise.resolve(async4()).then(() => {
                console.log(456);
        })
}
async function async4() {
   Promise.resolve().then(() => {
                console.log(789);
        })
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```





###### 8.7 Generator生成器函数

Generator函数是ES6引入的，主要用于异步编程。

Generator最大的特点就是可以交出函数的执行权（即暂停执行）。

```text
它和普通函数的写法不太一样，主要有两个不同：
1、function关键字与函数名之间有一个星号（*），它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号以示区别；
2、Generator函数体内部使用yield语句，可以定义不同的内部状态。
```

本质上，整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。

yield命令是异步不同阶段的分界线。

需要使用`.next()`方法启动Generator函数。作用是分阶段的执行Generator函数。每次调用`.next()`方法，会返回一个对象，表示当前阶段的信息，其中包括value属性和done属性。done为false表示函数还未执行完成，done为true表示函数已经执行完了。 

如果用同一个生成器函数声明的两个迭代器，他们之间是相互独立的，作用域独立。

```js
function * fn() {
    var n = 1;
    yield ++n;
    yield ++n;
    yield ++n;
}
// 声明两个迭代器
var aa = fn();
var bb = fn();

console.log(aa.next());  // 2
console.log(aa.next());  // 3
console.log(bb.next());  // 2
console.log(aa.next());  // 4
```

每当调用了一个迭代器内部的`.next()`方法，Generator函数内部的指针就会从上一次停下的地方继续执行，直到遇到下一个yield语句。

yield语句只能存在于Generator函数中，在普通函数中是不行的。

* Generator函数中的`.next()`方法可以接收参数：

  传入的参数其实是把上一个yield语句的返回值给覆盖了。第一个`.next()`方法其实是启动器，在他之前是没有yield语句的，所以给第一个`.next()`方法传参是没有意义的。

```js
function * fn() {
    var n = 1;
    var v = yield n + 22;
    console.log('v的值是：' + v);
    yield ++n;
    yield ++n;
}
var aa = fn();
console.log(aa.next());
console.log(aa.next('abc'));
console.log(aa.next());
```

执行结果是：

```js
{value: 23, done: false}
v的值是：abc
{value: 2, done: false}
{value: 3, done: false}
```

在上面的代码中，运行第一个`.next()`方法，它运行到第一个yield停止，返回的是n+22=23;`var v = yield n + 22`，这是一个赋值运算，到这个yield的时候，还没有运行到给v赋值的阶段，因为到了第一个yield就停了。

第二个next**传入的参数其实是把上一个yield的语句的返回值给覆盖了**，上一个yield语句的值是`yield = n + 22`,然后传入了abc，那么上一个yield语句的值被覆盖后就变成了`yield = 'abc'`，然后才赋值给了v，然后遇到下一个yield就又停了，此时经过++n之后n的值变为2。

第三个next，虽然前面yield的返回值被覆盖了，但是他并没有修改之前声明的变量n的值，n的值是2，++n后n的值就变成了3。



###### 8.8 Promise A+规范（手写Promise源码）



###### 8.9 JS底层运行机制：单线程和同步、异步编程

1）进程和线程的区别：

* 进程是资源分配的最小单位，线程是CPU调度的最先单位；
* 一个进程可以包含多个线程；
* 不同进程的数据之间很难共享，同一进程不同线程之间的数据很容易共享；
* 一个线程挂掉将导致整个进程挂掉，但是进程之间不会相互影响。

2）同步异步编程：

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕后才能够去执行下一个任务；

异步任务：不进入主线程，而是进入任务队列，只有主线程通知任务队列，某个异步任务可以执行了，这个任务才会进入主线程执行。

3）**异步编程的解决方案：**

* **回调函数：**把一个函数当参数，传递给另一个函数。回调函数是异步操作最基本的方法。

```js
ajax(url, () => {
    // 处理逻辑
})
```

是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：

```js
ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
```

优点：简单、容易理解和实现

缺点：不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况）

* **事件监听：**异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成后才能执行。首先，为f1绑定一个事件（这里采用的jQuery的写法）：

```js
f1.on('done', f2);
function f1() {
  setTimeout(function () {
    // ...
    f1.trigger('done');
  }, 1000);
}
```

上面代码中，f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。

优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"，有利于实现模块化。

缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。

* **发布订阅：**多个线程互相协作，完成异步任务

首先，f2向信号中心Event订阅done信号：

```js
Event.listen('done', f2);
```

然后，当f1状态发生变化的时候，就会通知订阅者：

```js
function f1() {
  setTimeout(function () {
    // ...
    Event.trigger('done');
  }, 1000);
}
```

上面代码中，Event.trigger('done')的意思是，f1执行完成后，向信号中心Event发布done信号，从而引发f2的执行。

订阅者监听发布者状态的变化，这种方法与事件监听相类似，但是要由于事件监听的方法。因为可以通过查看‘消息中心’来了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

* **Promise：**是ES6新增的一种新的写法，用来解决回调地狱问题。

```js
new Promise((resolve,reject) => {
  setTimeout(() => {
    resolve('hello')
  }, 2000)
}).then(res => {
  console.log(res)
})

new Promise((resolve,reject)=>{
  var a = 1;
  if(a == 1){
    reject('错误')
  }
}).catch(res => {
  console.log(res)
})

ajax(url)
  .then(res => {
      console.log(res)
      return ajax(url1)
  }).then(res => {
      console.log(res)
      return ajax(url2)
  }).then(res => console.log(res))
```

优点：让回调函数变成了规范的链式写法，程序流程可以看的很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到他们的状态都改变以后，再执行回调函数。

缺点：编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。

* **Generators：**是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator最大的特点就是可以控制函数的执行。

```js
function *gen() {
    for(let i = 0; i < 9999; i++){console.log(yield i)};
    yield 10;
    yield 20;
    return 30;
}
const it = gen();

console.log(it.next()); // { value: 10, done: false }
console.log(it.next()); // { value: 20, done: false }
console.log(it.next()); // { value: 30, done: true }
console.log(it.next()); // { value: undefined, done: true }
console.log(10)
console.log(it.next()); // { value: undefined, done: true }
```

特征：function关键字和函数之间有一个星号（*），且内部使用yield表达式返回数据，定义不同的内部状态，函数运行到yield关键字之后就停止了 。

换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段(done为false 继续执行)

普通函数的执行会形成一个调用栈，入栈和出栈是一口气完成的。而Generator必须得手动调用next()才能往下执行，相当于把执行的控制权从引擎交给了开发者。所以Generator解决的是流程控制的问题。它可以在执行过程暂时中断，先执行别的程序，但是它的执行上下文并没有销毁，仍然可以在需要的时候切换回来，继续往下执行。

最重要的优势在于，它看起来是同步的语法，但是却可以异步执行。

* **async/await：**Generator函数的语法糖。ES2017标准引入了async函数，使得异步操作变得更加方便。

```js
async function async1() {
        console.log('async1 start');  // (1)
        await async2();
        console.log('async1 end');  // (4)
    }
    async function async2() {
        console.log('async2');   // (2)
    }
    async1();
    console.log(123);  // (3)
```



###### 8.10 JS底层运行机制：微任务、宏任务和事件循环机制

1）JS的同步与异步：

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕后才能够去执行下一个任务；

异步任务：不进入主线程，而是进入任务队列，只有任务队列通知主线程，某个异步任务可以执行了，这个任务才会进入主线程执行。

2）JS中的宏任务、微任务与事件循环：

任务队列存在着两个队列：宏任务队列和微任务队列。

宏任务： I/O、定时器、事件绑定、AJAX...

微任务：promise.then  catch  finally      process.nextTick()....

*事件循环机制：*

* 所有同步任务都在主线程上执行，形成一个执行栈；
* 主线程之外存在一个任务队列，只要有了异步任务，就将其放置到任务队列中；
* 一旦执行栈中的所有同步任务执行完毕，系统就会去读取任务队列，队列遵循的原则是先入先出，但是有个条件，触发条件相等时才会遵循先入先出；如果触发条件不同，则优先执行达到触发条件的代码；
* 主线程不断重读上面的三个步骤。

*优先级：* 同步任务 > 异步任务（微任务 > 宏任务）



###### 8.11 Interator迭代器和for...of循环

想要通过一种统一的方法能够对所有数据类型进行遍历。

包括：Array、Map、Set、String、TypeArray、arguments、NodeList ...

以上几种数据类型可以遍历是因为这几种数据类型上实现了Iterator接口，比如数组中：

```js
let arr = [1, 2, 3];
for(let i of arr) {
    console.log(i);  // 1, 2, 3
}
```

对象obj不能遍历是因为obj内部没有部署迭代器。

任何数据结构只要部署了Iterator接口，就可以完成遍历操作。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201207100414940.png#)

```js
var arr = [1, 2, 3];
let iter = arr[Symbol.iterator]();
console.log(iter.next());  // {value: 1, done: false}
console.log(iter.next());  // {value: 2, done: false}
console.log(iter.next());  // {value: 3, done: false}
console.log(iter.next());  // {value: undefined, done: true}
```

1）迭代器本质：

迭代器对象本质上就是一个指针对象。通过指针对象的`next()`用来移动指针。

`[迭代器协议]`：对象必须提供一个next()，执行该方法要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代。

next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()。

ES6规定，默认的Iterator结构部署在数据结构的`Symbol.iterator`属性上。

2）自己实现一个迭代器：

```js
function myIter(arr) {
        var index = 0;
        return {
            next() {
                if (index < arr.length) {
                    return {
                        value: arr[index++], done: false
                    }
                }
                return {
                    value: undefined, done: true
                }
            }
        }
    }

    let arr = [1, 2, 3, 4];
    let iter = myIter(arr);
    console.log(iter.next());
    console.log(iter.next());
    console.log(iter.next());
    console.log(iter.next());
    console.log(iter.next());
```

3）遍历和迭代的区别：

遍历：将目标数据中的每一项访问到即可，不需要按照固定顺序。

迭代：是从目标源依次逐个抽取的方式来提取数据。

这里的目标源有两个条件：1、有序的；2、连续的。



#### 9、AJAX/HTTP前后端数据交互

------

###### 9.1 AJAX核心五步操作

1）什么是AJAX？

Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。*常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等*。Ajax的目的是提高用户体验，较少网络数据的传输量。同时，由于AJAX请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。

2）AJAX原理：

Ajax请求数据最核心的依赖是浏览器提供的XMLHttpRequest对象，它使得浏览器可以发出HTTP请求与接受HTTP响应。浏览器可以接着做其他事情，等收到XHR返回来的数据再渲染页面。

3）AJAX的使用：

1、创建一个XHR对象：

此时最好要考虑不同浏览器之间兼容性的问题：

```js
var xhr=null;  
if (window.XMLHttpRequest)  
	{// 兼容 IE7+, Firefox, Chrome, Opera, Safari  
	   xhr=new XMLHttpRequest();  
	} else{// 兼容 IE6, IE5 
	     xhr=new ActiveXObject("Microsoft.XMLHTTP");  
	} 
```

2、设置请求方式和请求地址：

```js
xhr.open(method,url,async);  
```

* method：请求的方式： GET/POST
* url：文件在服务器上的位置
* async：同步（false）还是异步（true）

3、发送请求：

```js
send();
```

注意：post请求时才使用字符串参数，否则不用带参数。

**post请求一定要设置请求头的格式内容**

```js
xhr.open("POST","test.html",true);  
xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");  
xhr.send("fname=Henry&lname=Ford");  //post请求参数放在send里面，即请求体
```

4、监听状态变化：

responseText 获得字符串形式的响应数据。

responseXML 获得XML 形式的响应数据。

* **同步处理：**

```js
xhr.open("GET","info.txt",false);  
xhr.send();  
//获取数据直接显示在页面上
document.getElementById("myDiv").innerHTML=xhr.responseText; 
```

* **异步处理：**要在请求状态改变事件中处理

```js
xhr.onreadystatechange=function()  { 
if (xhr.readyState==4 &&xhr.status==200)  { 
		document.getElementById("myDiv").innerHTML=xhr.responseText;  
	}
} 
```

**什么是readyState？**

readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。 readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义

​	0：尚未初始化，但已经创建了XHR对象；

​	1：已经调用了open方法，但尚未调用send方法；

​	2：已经调用了send方法，但尚未接收到响应；

​	3：已经接收到了部分响应数据；

​	4：已经接收到全部响应数据，而且已经可以在客户端使用了。

**什么是status？**

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，HTTP状态码共分为5种类型：

5、处理返回结果：

比如下面代码中，将获取到的数据加载到`myDiv`

```js
xhr.onreadystatechange=function()  { 
if (xhr.readyState==4 &&xhr.status==200)  { 
		document.getElementById("myDiv").innerHTML=xhr.responseText;  
	}
}
```

来个整合：综合示例

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试AJAX请求</title>
</head>

<body>
    <button class="btn">点我发送请求</button>
    <div id="app"></div>
</body>
<script src="./js/axios.js"></script>
<script>

    document.querySelector('.btn').onclick = function () {
        // 1、创建一个xhr对象
        var xhr = new XMLHttpRequest();
        // 2、设置请求方式和请求地址
        xhr.open('get', 'http://localhost:5000/getTest');
        // 3、发送请求
        xhr.send();
        // 4、监听状态变化
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                // 5、处理返回结果
                document.querySelector("#app").innerHTML = xhr.responseText;
            }
        }
    }
</script>

</html>
```



###### 9.2 GET/POST核心机制与区别

1）**GET:**

* GET请求的数据会附加在URL之后，用问号分割，多个参数用&进行连接。

* GET请求的数据会暴露在地址栏中。

* GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。

* GET请求传输大小有限制，大小在2KB。

* GET相对安全性较差，会被浏览器主动缓存。

* GET产生一个TCP数据包，head和data一起发送。

* GET浏览器回退无害。

2）**POST:**

* POST请求会把数据放置在HTTP请求体中，不会直接暴露给用户。

* POST请求理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。

* POST相对Get更安全，因为参数不会保存在浏览器历史或者是web服务器日志中。

* POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续发送data，服务器200然后返回数据。

* POST浏览器回退重新请求。



###### 9.3 TCP三次握手与四次挥手、与UDP的比较

**1）TCP/IP网络模型：**

计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为**协议（protocol）**。

TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。

在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。

**OSI七层模型和TCP/IP五层模型：**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/24/1691ff760cca10b3~tplv-t2oaga2asx-image.image)

2）TCP:

TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

**1、TCP的连接过程：**（三次握手）

如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/24/1691fa18ef700560~tplv-t2oaga2asx-image.image" alt="img" style="zoom:150%;" />

*第一次握手：*客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

*第二次握手：*服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

*第三次握手：*当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

**2、TCP断开连接的过程：**（四次挥手）

如下图所示，可以看到断开一个TCP连接的过程为（四次挥手的过程）：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/24/1691fad9308022c9~tplv-t2oaga2asx-image.image)

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

*第一次挥手：*若客户端 认为数据发送完成，则它需要向服务端发送连接断开请求。

*第二次挥手：*服务器收到连接断开请求后，会告诉应用层要断开TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务器的连接已经断开，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务器仍旧可以发送数据给客户端。

*第三次挥手：*服务器如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接断开请求，然后服务器便进入 LAST-ACK 状态。

*第四次挥手：*客户端收到断开请求后，向服务器发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有服务器的重发请求的话，就进入 CLOSED 状态。当服务器收到确认应答后，也便进入 CLOSED 状态。

为什么挥手要进行四次？
因为服务器端发送确认客户端断开的ACK之后，还要进行数据处理，处理完数据之后才可以发送自己的断开请求。这里不能合并成一个请求过程。

3、TCP协议的特点：

* 面向连接：是指发送数据之前，必须在两端建立连接。建立连接的方法是”三次握手“，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。
* 仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。
* 面向字节流：TCP不像UDP那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。
* 可靠传输：对于可靠传输、判断丢包。误码，靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
* 提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞
* TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

3）UDP:

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

UDP协议的特点：

* 面向无连接的：首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是，在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头，标识下是UDP协议，然后就传递给网络层了；在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会进行任何拼接操作。

* 有单播、多播、广播的功能：UDP不只支持一对一的传输方式，同样支持一对多、多对多和多对一的方式，也就是说UDP提供了单播、多播、广播的功能。

* UDP是面向报文的：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。

* 不可靠性：首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

* 头部开销小，传输数据报文时是很高效的：UDP头部包含了以下几个数据：

  * 两个十六位的端口号，分别是源端口（可选字段）和目标端口；
  * 整个数据报文的长度；
  * 整个数据报文的检验和（IPv4可选字段），该字段用于发现头部信息和数据中的错误。

  <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/24/1691f340e82df2d5~tplv-t2oaga2asx-image.image" alt="img" style="zoom:150%;" />

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

4）TCP和UDP的比较：

[![O8BbLT.png](https://s1.ax1x.com/2022/05/09/O8BbLT.png)](https://imgtu.com/i/O8BbLT)



###### 9.4 axios库和源码剖析

1）axios是什么？

Axios是一个基于Promise和node.js的http客户端。

2）axios的特性：

* 从浏览器中创建XMLHttpRequest
* 从node.js中创建http请求
* 支持Promise API
* 能够拦截请求和响应
* 转换请求数据和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防御CSRF

实际上，axios可以用在浏览器和 node.js 中是因为，它会自动判断当前环境是什么，如果是浏览器，就会基于**XMLHttpRequests**实现axios。如果是node.js环境，就会基于node**内置核心模块http**实现axios。

3）axios的基本使用方式：

* 使用默认方式发送请求：axios(config)

```js
document.querySelector('.btn').onclick = function () {
        // 分别使用以下方法调用，查看myaxios的效果
        axios({
            method: 'get',
            url: 'http://localhost:5000/getTest'
        }).then(res => {
            console.log('getAxios 成功响应', res);
        })
    }
```

* axios.method(url, data , config)

```JS
document.querySelector('.btn').onclick = function () {
        axios.get('http://localhost:5000/getTest')
            .then(res => {
                console.log('getAxios 成功响应', res);
            })
    }
```

4）请求拦截器和响应拦截器：

1、请求拦截器：

请求拦截器就是在我们发送一个请求的时候会先执行请求拦截器的代码，然后再真正地执行我们发送的请求，这个过程会对request也就是我们发送请求时传送的参数进行一些操作。

```js
// 添加请求拦截器
    axios.interceptors.request.use(function (req) {
        // 在发送请求之前做些什么
        console.log('我请求了');
        return req;
    }, function (error) {
        // 对请求错误做些什么
        return Promise.reject(error);
    });
```

2、响应拦截器：

响应拦截器就是当接收响应的时候，会先执行响应拦截器的代码，然后再把响应的数据返回来，这个过程会对response也就是响应的数据进行一系列操作。

```js
// 添加响应拦截器
    axios.interceptors.response.use(function (res) {
        // 对响应数据做点什么
        console.log('我响应了');
        return res;
    }, function (error) {
        // 对响应错误做点什么
        return Promise.reject(error);
    });
```

可见，axios实例上有一个对象interceptors。这个对象有两个拦截器，一个用来处理请求，一个用来处理响应。

所以，我们执行语句`axios.interceptors.response.use`和`axios.interceptors.request.use`的时候，实现获取axios实例上的interceptors对象，然后再获取response或request拦截器，再执行对应的拦截器的use方法。



###### 9.5 fetch基础

1）fetch简介：

在 传统Ajax 时代，进行 API 等网络请求都是通过XMLHttpRequest或者封装后的框架进行网络请求,然而配置和调用方式非常混乱，对于刚入门的新手并不友好。Fetch提供了一个更好的替代方法，它不仅提供了一种简单，合乎逻辑的方式来跨网络异步获取资源，而且可以很容易地被其他技术使用，例如 Service Workers。

[![O8BzWR.png](https://s1.ax1x.com/2022/05/09/O8BzWR.png)](https://imgtu.com/i/O8BzWR)

2）与AJAX对比：

使用AJAX请求一个JSON格式的数据如下：

```js
document.querySelector('.btn').onclick = function () {
        // 1、创建一个xhr对象
        var xhr = new XMLHttpRequest();
        // 2、设置请求方式和请求地址
        xhr.open('get', 'http://localhost:5000/getTest');
        // 3、发送请求
        xhr.send();
        // 4、监听状态变化
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                // 5、处理返回结果
                document.querySelector("#app").innerHTML = xhr.responseText;
            }
        }
    }
```

同样使用fetch的方式请求JSON数据如下：

```js
document.querySelector('.btn').onclick = function () {
        fetch('http://localhost:5000/getTest').then(res => {
            return res.json();  // 解析为可读数据
        }).then(data => {   // 执行结果为resolve就调用then方法
            document.querySelector('#app').innerHTML = JSON.stringify(data);
            console.log(data);
        }).catch(err => console.log(err)) // 执行结果为reject就调用catch方法
    }
```

fetch方法返回一个Promise对象, 根据 Promise Api 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch。一旦then中的语句出现错误, 也将跳到catch中。

从两者对比来看，fetch代码精简许多，业务逻辑更清晰明了，使得代码易于维护，可读性更高。 总而言之，Fetch 优点主要有：

```text
1、语法简介，更加语义化，业务逻辑清晰；
2、基于标准Promise实现，支持async/await；
```



 ###### 9.6 前端开发中的9种跨域方案

1）什么是同源策略及其限制内容？

同源策略是一种约定，是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指“协议+域名+端口”三者相同，只要有一个不同就是跨域。

![url的组成](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579d9eeb32~tplv-t2oaga2asx-no-mark:1280:960:0:0.awebp)

但是有三个标签是允许跨域加载资源：

* `<img src="">`
* `<link href="">`
* `<script src="">`

2）常见跨域场景：

当协议、域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算做跨域。常见的跨域场景如下图所示：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579dde630e~tplv-t2oaga2asx-no-mark:1280:960:0:0.awebp)

这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？

跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

3）**跨域解决方案：**

**1、JSONP：**

* 利用`<script>`标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才可以。

2、JSONP和AJAX对比：

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。

3、JSONP优缺点：

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

4、JSONP的实现流程：

* 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。

* 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。

* 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('哈哈哈')`。

* 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

前台html页面：

```js
function jsonp({ url, params, callback }) {
        return new Promise((resolve, reject) => {
            let script = document.createElement('script');
            window[callback] = function (data) {
                resolve(data);
                document.body.removeChild(script);
            }
            params = { ...params, callback };
            let arr = [];
            for (let key in params) {
                arr.push(`${key}=${params[key]}`);
            }
            script.src = `${url}?${arr.join('&')}`;
            document.body.appendChild(script);
        })
    }
    jsonp({
        url: 'http://localhost:5000/list',
        params: { name: 'zhangsan' },
        callback: 'show'
    }).then(res => {
        console.log(res);
    })
```

后台服务器：

```js
let express = require('express')
let app = express()
app.get('/list', function (req, res) {
    let { callback } = req.query;
    let data = {
        message: 'nihao~'
    }
    res.send(`${callback}(${JSON.stringify(data)})`);
})
app.listen(5000, () => { console.log('服务器启动了...'); });
```

上面这段代码相当于向`http://localhost:5000/list?name=zhangsan&callback=show`这个地址请求数据，然后后台返回`show('hahaha~')`，最后会运行show()这个函数，打印出'hahaha~'

5）基于jQuery的JSONP形式：

JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。

前台html页面：

```js
$.ajax({
        url: "http://localhost:5000/list",
        dataType: "jsonp",
        type: "get",//可以省略
        success: function (data) {
            console.log(data);
        }
    });
```

后台数据和前面的相同。

**2）CORS（跨域资源共享）：**

**CORS 需要浏览器和后端同时支持。**

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

1、简单请求：

只要同时满足以下两大条件，就属于简单请求

条件1：使用下列方法之一：

- GET
- HEAD
- POST

条件2：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

2、复杂请求：

不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

3）http  proxy代理：

4）nginx反向代理：

5）post message:

6）websocket:

7）window.name + iframe:

8）document.domain + iframe:

9）location.hash + iframe:



###### 9.7 HTTP网络状态码

* 1xx: 继续
  * 101 Switching Protocols：浏览器请求切换协议，服务器已收到并准备切换；
* 2xx: 成功
  * 200 OK：请求成功；
  * 204 No Content：无内容。没有响应数据；
  * 206 Partial Content：部分内容；
* 3xx：重定向
  * 301 Moved Permanently：永久重定向；
  * 302 Moved Temporarily：临时重定向；
  * 304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。当协商缓存命中时会返回此状态码；
* 4xx: 客户端错误
  * 400 Bad Request：错误请求；
  * 403 Forbidden：服务器禁止访问；
  *    Not Found：找不到资源；
  * 405 Method Not Allowed：方法被禁用；
  * 406 Not Acceptable：未接受，资源无法满足客户端的条件；
  * 408 Request Timeout：请求资源超时；
* 5xx: 服务器错误
  * 500 Internal Server Error: 服务器错误
  * 501 Not Implemented：未实施，客户端请求的功能还不支持
  * 502 Bad Gateway：错误网关；
  * 503 Service Unavailable: 服务器不可用。



###### 9.8 前端性能优化汇总

**1、资源压缩与合并：**

主要包括这些方面：**html压缩、css 压缩、js的压缩和混乱和文件合并**。 资源压缩可以从文件中去掉多余的字符，比如回车、空格。你在编辑器中写代码的时候，会使用缩进和注释，这些方法无疑会让你的代码简洁而且易读，但它们也会在文档中添加多余的字节。

1）html压缩：

html代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩。

如何进行html压缩：

```text
1、使用在线网站进行压缩(开发过程中一般不用)
2、nodejs 提供了html-minifier工具
3、后端模板引擎渲染压缩
```

2）css代码压缩：

css代码压缩简单来说就是删除无效代码和css语义合并。

如何进行css压缩：

```text
1、使用在线网站进行压缩(开发过程中一般不用)
2、使用html-minifier工具
3、使用clean-css对css压缩
```

![css 压缩](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/21/163807b8c46632c2~tplv-t2oaga2asx-zoom-crop-mark:1280:960:0:0.awebp)

3）js的压缩和混乱：

js的压缩与混乱主要包括以下这几部分:

```text
1、无效字符的删除
2、剔除注释
3、代码语义的缩减和优化
4、代码保护(代码逻辑变得混乱，降低代码的可读性，这点很重要)
```

如何进行js的压缩与混乱：

```text
1、使用在线网站进行压缩(开发过程中一般不用)
2、使用html-minifier工具
3、使用uglifyjs2对js进行压缩
```

4）文件合并：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/30/163b1b2e78785581~tplv-t2oaga2asx-zoom-crop-mark:1280:960:0:0.awebp)

压缩合并css和js可以减少网站http请求的次数，但合并文件可能会带来问题:首屏渲染和缓存失效问题。那该如何处理这问题呢？----公共库合并和不同页面的合并。

如何进行文件合并：

```text
1、使用在线网站进行文件合并
2、使用nodejs实现文件合并(gulp、fis3)
```

**2、非核心代码异步加载：**

1）异步加载的方式：

* defer：
  * 兼容所有浏览器；
  * defer属性规定是否对页面脚本执行进行延迟，直到页面加载为止；
  * 如果时多个脚本，该方法可以确保所有设置了defer属性的脚本按照顺序执行；
  * 如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度。
* async:
  * async属性是HTML5新增的属性，需要Chrome，Firefox，IE9+浏览器的支持；
  * async属性规定一旦脚本可用，则会异步执行；
  * async属性仅适用于外部脚本；
  * 如果是多个脚本，则不能保证脚本按顺序执行。

```js
<script type="text/javascript" src="xxx.js" async="async"></script>
```

* 动态创建script标签：

在还没定义defer和async前，异步加载的方式是动态创建script，通过window.onload方法确保页面加载完毕再将script标签插入到DOM中.

2）**异步加载的区别：**

* defer是在html解析完成之后才会执行，如果是多个，会按照加载顺序执行；
* async是在加载完之后立即执行，如果是多个，执行顺序与加载顺序无关。

**3、利用浏览器缓存：**

**4、利用CDN：**

大型Web应用对速度的追求并没有止步于仅仅利用浏览器缓存，因为浏览器缓存始终只是为了提升二次访问的速度，对于首次访问的加速，我们需要从网络层面进行优化，最常见的手段就是CDN（Content Delivery Network，内容分发网络）加速。通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载。

CDN是怎么做到加速的呢？

其实这是CDN服务商在全国各个省份部署计算节点，CDN加速将网站的内容缓存在网络边缘,不同地区的用户就会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。

**5、预解析DNS：**

资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。 通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。例如，我们将来可从 example.com 获取图片或音频资源，那么可以在文档顶部的标签中加入以下内容：

```js
<link rel="dns-prefetch" href="//example.com">
```

当我们从该 URL 请求一个资源时，就不再需要等待 DNS 的解析过程。该技术对使用第三方资源特别有用。通过简单的一行代码就可以告知那些兼容的浏览器进行 DNS 预解析，这意味着当浏览器真正请求该域中的某个资源时，DNS 的解析就已经完成了,从而节省了宝贵的时间。 另外需要注意的是，浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。但是在HTTPS下不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。下面这句话作用是强制打开a标签域名解析：

```js
<meta http-equiv="x-dns-prefetch-control" content="on">
```

###### 9.9  强缓存与协商缓存

HTTP缓存是前端开发中最常接触的缓存机制之一，它又可细分为强缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。

**强缓存**：对于强缓存而言，如果浏览器判断所请求的目标资源有效命中，则可以直接从强缓存中返回请求响应，无需与服务器进行任何通信。

强缓存是利用http头中的pragma和cache-Control两个字段来控制的，用来表示资源的缓存时间。

**协商缓存**：顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。

```text
1、我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中expires、pragma或者cache-control字段，代表这是强缓存，浏览器就会把资源缓存在memory cache 或 disk cache中。
2、第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新资源。
```





####  10、计算机网络部分

###### 10.1 GET和POST的区别：

* 功能不同：GET常用来查询数据，POST是用来提交数据
* GET没有请求实体，POST有请求实体
* GET的请求参数是明文的，暴露在URL地址当中；而POST的参数在请求体当中；
* GET不安全；POST更加安全
* 数据大小限制：GET数据大小限制在1kb之内；POST理论上没有数据大小限制
* 编码方式不同：GET采用的是ASCII编码，而POST有多种编码方式，比如说URL编码
* GET请求会被保存在浏览器的历史记录当中，但是POST不会
* GET的回退是无害的，POST会重新请求



###### 10.2 TCP和UDP的区别：

[![O8BbLT.png](https://s1.ax1x.com/2022/05/09/O8BbLT.png)](https://imgtu.com/i/O8BbLT)



###### 10.3 HTTP和HTTPS（包括HTTP1.0/1.1/2.0）

**1、HTTP和HTTPS的基本概念：**

1）HTTP是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（基于TCP/IP）；

2）HTTPS是经过SSL/TLS加密的HTTP协议，简单来说就是HTTP的安全版；

**2、HTTP和HTTPS的主要区别：**

1）HTTP是超文本传输协议，信息是明文传输的，更不安全；而HTTPS是经过SSL/TLS加密的HTTP协议，更加安全；

2）HTTP标准端口是80；而HTTPS的标准端口是443；

3）HTTP不需要认证证书；而HTTPS需要申请CA证书，一般免费的较少；

4）HTTP的连接很简单，是无状态的；而HTTPS是由SSL+HTTP协议构建的可进行加密传输的网络协议。

**3、HTTPS的工作原理：**

1）客户端使用https的URL访问服务器，要求与Web服务器建立SSL连接；

2）服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端；

3）客户端与服务器开始协商SSL连接的安全等级，也就是信息加密的等级；

4）客户端根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密并传送给服务器；

5）服务器利用自己的私钥解密出会话密钥；

6）服务器利用会话密钥加密与客户端之间的通信。

`原理分析`：实质上利用到了对称加密和非对称加密两种加密手段，通过对称加密对数据加密，通过非对称加密对 对称加密的密钥加密。

![image-20210608161818224](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40c61fb691a45e09b5c3f2e7664d353~tplv-k3u1fbpfcp-watermark.awebp)

**4、HTTP1.1**

1）长连接：引入长连接，就是TCP连接默认不关闭，可以被多个请求复用，通过请求头connection:keep-alive设置；

2）节约带宽：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3）HOST域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

4）缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

5）错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**5、HTTP2.0**

1）二进制分帧：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

2）多路复用：一个连接上可以有多个请求，采用多路复用可以并发处理多个请求；

3）头部数据压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

4）服务器推送：允许服务器预先将网页所需要的资源push到浏览器的内存当中。



#### 11、VUE响应式原理：





#### 12、前端安全：

###### 12.1 XSS（Cross Site Script，跨站脚本攻击）

1、XSS是什么：

XSS攻击是指攻击者在网站上注入恶意的客户端代码。通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括JavaScript，有时也会包含HTML和Flash。有很多种方式进行XSS攻击，但他们的共同点为：将一些隐私数据像cookie和session共发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

2、XSS类型：

XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM

1）反射型（Reflected XSS）: 发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS.

2）存储型 （Stored XSS）: 和Reflected XSS的差别就在于具有攻击性的脚本被保存到了服务器端（数据库、内存、文件系统等）并且可以被普通用户完整的从服务器取得并执行，从而获得了在网络上传播的能力。

3）DOM型（DOM-based or local XSS）: 即基于DOM或本地的XSS攻击，其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。可以通过DOM来动态地修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。

2、XSS攻击的特点：

将一些隐私数据像cookie和session共发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

3、如何防范XSS攻击：

1）输入过滤，避免XSS的方法之一主要是将用户输入的内容进行过滤。对所有用户提交的内容进行可靠的输入验证，包括对URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所于其的字符的内容提交，对其他的一律过滤（客户端和服务器都要）。

2）输出转义：相当于输出也做一个过滤。例如往HTML标签中插入不可信数据时，首先要做的就是对不可信数据进行HTML Entity编码。

3）使用HttpOnlyCookie: 加一些请求头：

将重要的cookie标记为httponly，这样的话当浏览器向web服务器发起请求的时候就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie了。



###### 12.2 CSRF（Cross-site Request Forgery，跨站请求伪造）

1、CSRF是什么：

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

2、CSRF攻击的特点：

* 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

* 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

* 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

* 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

3、如何防范CSRF攻击：

1）使用http referer字段：

根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。

2）使用token：

CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。

3）验证码验证：

每进行异步操作，可以采取验证码进行验证。这种方式用的较少。



#### 13、VUE

###### 13.1 Vuex

1、当前企业开发所面临的两个问题

1）如果想要在子组件中使用祖先组件中的数据，那么就必须一层层的传递，非常麻烦；

2）兄弟组件之间不能直接传递数据，如果兄弟组件之间想要传递数据，那么就必须借助父组件，非常麻烦。

结局方案：使用Vuex

2、什么是Vuex

vuex是vue配套的公共数据管理工具，我们可以将共享的数据保存到vuex中，方便整个程序中的任何组件都可以获取和修改vuex中保存的公共数据。

注意点：

* 必须在引入Vue后才能引入Vuex；
* 只有需要共享的才放到vuex中，不需要共享的数据依然放到组件自身的data中；
* 在Vuex中不推荐直接修改共享数据，如果多个组件都修改了共享的数据，那么后期数据发生了错误，我们如果需要去调试错误，就需要把每一个修改了共享数据的组件都检查一边，非常的低效，非常的不利于维护。

3、Vuex的使用

```vue
const store = new Vuex.store({
	state: {
		count:0
	},
	mutations: {
		mAdd(state) {
			state.count = state.count + 1;
		}
	},
	getters: {
	
	},
	actions: {
	
	},
	modules: {
	
	}
})
```

1）、state：用于保存共享数据

通过`this.$store.state.msg`来进行访问

2）、mutations：用于保存修改共享数据的方法

注意：在执行mutations方法时，系统会自动给这些方法传递一个state参数，state中就保存了共享数据，这样就可以拿到并操作共享数据了。

调用方式：在组件的对应的方法中，通过`this.$store.commit('mAdd')`即可调用

3）、getters：Vuex的getters属性就和组件的计算属性一样，会将数据缓存起来，只有当数据发生变化时才会重新计算。

注意：在执行getters方法时，系统也会自动给这些方法传递一个state参数，state中就保存了共享数据，这样就可以拿到并操作共享数据了。

4）、action：可以理解为通过mutations中处理数据的方法变成可异步的处理数据的方法，简单来说就是异步操作数据。

5）、modules：项目特别复杂的时候，可以让每一个模块都拥有自己的state、mutation、action、getter和module，使得结构更加清晰，方便管理。

4、mutation和action有什么区别：

* action提交的是mutation，而不是直接变更状态（state）； mutation可以直接变更状态；
* action可以包含任意异步操作；mutation只能包含同步操作；
* 提交方式不同，action 是用this.store.dispatch('ACTION_NAME',data)来提交；mutation是用this.$store.commit('SET_NUMBER',10)来提交。



###### 13.2 Vue中组件八种通信方法

1、父向子组件传值：`props`

父组件通过子组件暴露的prop向子组件传值。子组件通过内部定义的props接收到父组件的值,每当父组件的值变化的时候，子组件内部的值就会发生变化，可以使用`this.[props]`来进行引用。

2、子向父组件传值：自定义事件`$emit`

组件向父组件传值其实就是`触发事件`然后通过事件传参返回给父组件。

3、父调用子组件：`vm.$refs`

通过`vm.$ref`在父组件中引入子组件并且设置子组件的ref值。`ref="son"`

4、子调用父组件：`vm.$parent`

通过`vm.$parent`在子组件中引入父组件实例。

5、兄弟组件传值：事件总线`eventBus`

通过`vm.$emit`和`vm.$on`，通过 `vm.$emit` 触发当前实例上的事件，并将参数传递给监听器，通过 `vm.$on` 监听当前实例上的自定义事件。

6、`vm.$attrs`和`vm.$listeners`：

props和$emit的父子组件传值的进化版。可以从父组件到孙组件的跨级传递，中间的子组件作为`vm.$attrs`和`vm.$listeners`的实现载体

总结：`vm.$attrs`和`vm.$listeners`都可以实现从父组件将值和事件跨级（上下游，兄弟组件不可）传递，但是在中间的组件（子组件）需`v-bind="$attrs" v-on="$listeners"`要绑定传值。

7、provide / inject:

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。只有数据向下传递，并没有事件响应向上。可以向下跨级传递，子、孙只要有inject均可。

8、vuex：

通过使用数据存储仓库来进行组件的值的交互。建议使用vuex管理大型项目中的各个组件之间的值通讯。可以围绕vuex的状态控制来生成多个组件的关联。

具体使用内容见13.1



###### 13.3 Vue-cli

1、CLI是什么意思：

* cli是Command-Line Interface，翻译为命令行页面，俗称为脚手架；
* Vue-cli是一个官方发布的基于vue.js的项目脚手架
* 使用vue-cli可以快速搭建vue开发环境以及对应的webpack配置。

2、安装Vue脚手架：

* npm install -g @vue/cli

拉取2.x模板（旧版本）：

Vue CLI 3和旧版是用了相同的vue命令，所有vue cli2(vue-cli)被覆盖了，如果仍需要使用旧版本的vue init功能，可以全局安装一个桥接工具

```shell
npm install -g @vue/cli-init
# `vue init` 的运行效果将会跟 `vue-cli@2.x`相同
vue init webpack my-project
```



###### 13.4 请详细说下对Vue生命周期的理解

一个Vue实例从最开始创建到最后销毁所经历的各种状态就是一个Vue实例的生命周期。

* 创建阶段的生命周期：
  * beforeCreate：在这个阶段Vue实例刚刚创建但尚未初始化完成，此时不可以访问Vue实例中的数据和方法；
  * Created：在这个阶段Vue实例已经初始化完成了，这个时候是最早能够访问到Vue实例中的数据的时候；
* 挂载阶段的生命周期：
  * brforeMount：在这个阶段Vue实例模板已经编译完成了，但尚未渲染到页面上；
  * Mounted：在这个阶段Vue实例挂在完成，已经渲染到页面上了；
* 更新阶段的生命周期:
  * beforeUpdate：当Vue实例中的数据更新时会调用此钩子函数，此时Vue实例中的数据已经发生改变，但页面上上的数据尚未发生改变；
  * Updated：在这个阶段Vue实例中的数据和页面上的数据均已完成更新；
* 销毁阶段的生命周期：
  * beforeDestroy：当Vue实例要销毁时会调用此钩子函数，此阶段是最后能够访问到Vue实例中的数据的阶段；
  * Destoryed：在这个阶段Vue实例已经被销毁，Vue实例中的数据也不可访问。调用后，Vue实例知识的所有东西都会接绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。



###### 13.5 为什么Vue组件中的data必须是一个函数？为什么Vue根组件中的data不需要是函数？

1、对象为引用类型，当复用组件的时候，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他复用的组件中的data也会被修改，造成数据冲突；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现数据冲突的问题。

2、Vue根组件只有一个，其data采用对象的方式并不会与其他的组件产生冲突，因此并不需要是函数。



###### 13.6 v-if和v-show的区别

1、v-if是通过条件判断元素是否显示与隐藏的，如果为true则进行渲染，如果为false则不进行渲染，有着更高的切换消耗，适用于那些一经确定就不经常发生变化的元素

2、v-show不管是true还是false都会进行渲染，只是当v-show的值为false时相当于给元素一个display:none的属性让它不显示。v-show有着较高的初始渲染消耗，适用于那些经常切换的元素。



###### 13.7 计算属性computed和侦听器watch的区别

1、计算属性computed：

* 计算属性支持缓存，只有依赖的数据发生改变，才会重新进行计算；

注：是否所有的依赖的数据发生变化时都会导致计算属性的值得变化？不是的，只有当添加到Vue实例中的数据发生变化时，相应的计算属性的值才会发生变化，没有添加到Vue实例中的数据，计算属性的值是不会发生变化的。

* 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。

2、侦听器watch：

* 侦听器是不支持缓存的，是实时监听的，当所监听的数据发生变化时，会触发相应的操作；
* 侦听器watch支持异步



###### 13.8 $nextTick是什么？

nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调函数中获取到更新之后的 DOM。

应用场景：

* created()钩子函数中的DOM操作一定要放在this.nextTick()的回调函数中，因为在created()时虽然数据可以调用，但是DOM并没有进行更新，所以操作DOM是无效的。
* 当项目中要对改变之后的DOM元素做一定的操作时，将操作放在this.nextTick()的回调函数中。
* 使用某些第三方插件时，想要在vue生成的某些DOM发生变化后重新应用该插件时，需要在this.nextTick()的回调函数中重新执行该插件的方法



###### 13.9 v-for中key的作用

使用`v-for`更新已渲染的元素列表时,会使用虚拟DOM和diff算法， 默认使用**就地复用**的策略;列表数据修改的时候,会根据key值去判断新旧虚拟DOM是否发生变化,如果发生变化,则重新渲染这一项,否则复用之前的内容; 

最好的办法是使用数组中不会变化的那一项作为`key`值,比如说每条数据都有一个唯一的`id`,来标识这条数据的唯一性;使用唯一的`id`值作为`key`值。 

**为什么使用id值作为key的值而不使用index作为key的值？**

因为用index作为key可能会引发一些问题：

* 若对数据进行逆序添加或逆序删除等破坏顺序的操作时，会产生没有必要的真实DOM的更新；
* 如果结构中还包含输入类DOM，会产生错误的DOM更新。



###### 13.10 Vue如何监听对象或者数组某个属性的变化

当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到对象或者数组某个属性的变化。

解决方法：

* this.$set(你要改变的数组/对象，你要改变的位置key，你要改成什么value)

```JavaScript
this.$set(this.arr, 0, "OBKoro1"); // 改变数组
this.$set(this.obj, "c", "OBKoro1"); // 改变对象
```

* 调用以下几个数组的方法：

```JavaScript
push()、pop()、shift()、unshift()、sort()、reverse()、splice()
```

vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作。

* Vue3 中采用proxy的方式：

3.0中使用es6中的Proxy来代替Object.defineProperty，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，可以监听到对象属性的增删和数组长度的变化。 

###### 13.11 常用的事件修饰符

* `.stop`：阻止冒泡；
* `.prevent`：阻止默认行为；
* `.self`：仅绑定元素自身触发；
* `.once`：只触发一次；
* `.passive`：事件滚动的默认行为（即滚动行为）将会立即触发，不能和`.prevent`一起使用；
* `.sync`：作为一个编译时的语法糖存在，它会被扩展为一个自动更新父组件属性的v-on监听器。

###### 13.12  Vue如何获取DOM

先给标签设置一个ref值，再通过`this.$refs.domName`获取，例如：

```vue
<div ref="test"></div>
const dom = this.$refs.test
```



###### 13.14 Vue项目文件中assets和static的区别

这两个都是用来存放项目中所使用的静态资源文件。

两者的区别：

* assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。

* static中的文件则不会被打包。

> 建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。



###### 13.15 Vue初始化页面时闪动的问题

使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。解决方法：

```css
[v-cloak] {
    display: none;
}
```

如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"



###### 13.16 虚拟DOM的优缺点

**优点：**

* 无需手动操作DOM：我们不再需要手动去操作DOM，只需要写好View-MOdel的代码逻辑，框架会根据虚拟DOM的双向数据绑定，帮我们以可预期的方式更新视图，极大的提高了开发效率。
* 跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下，虚拟DOM可以进行更方便地跨平台操作，例如服务端渲染，weex开发等。

**缺点：**

* 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入得慢。





#### 14、数组去重

###### 1、双重for循环：

双重for循环遍历数组，重复的删除即可。

```js
function data(arr) {
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] === arr[j]) {
                    arr.splice(i, 1);
                }
            }
        }
        return arr;
    }
```

###### 2、ES6中set的方法：拓展运算符

```js
function data(arr) {
        let set = new Set(arr);
        return [...set];
    }
```

###### 3、使用indexOf方法：如果新数组中没有则返回-1

```js
function data(arr) {
        let newArr = [];
        arr.forEach(item => {
            if (newArr.indexOf(item) === -1) {
                newArr.push(item);
            }
        });
        return newArr;
    }
```

###### 4、使用indexOf方法：该元素索引与第一次出现元素的索引不同则为重复元素

```js
function data(arr) {
        let newArr = [];
        arr.forEach((item, index) => {
            if (arr.indexOf(item) === index) {
                newArr.push(item)
            }
        });
        return newArr;
    }
```

###### 5、使用sort排序后，比较相邻元素是否重复：

```js
function data(arr) {
        arr.sort((a, b) => a - b);
        for (let i = 0; i < arr.length; i++) {
            if (arr[i + 1] === arr[i]) {
                arr.splice(i, 1);
            }
        }
        return arr;
    }
    console.log(data(arr));
```

###### 6、利用set与array.from：

`Array.from()` 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

```js
function data(arr) {
        return Array.from(new Set(arr));
    }
```

###### 7、利用filter（ES5去重的方法）

```JavaScript
function data(arr) {
    let newArr = arr.filter((item, index) => {
        return arr.indexOf(item) == index;
    })
    return newArr;
}
```





#### 15、Canvas和SVG的区别

* canvas绘制出来的图形一般是位图，也就是放大缩小的情况下会出现失真的情况；svg绘制的图形是矢量图，不存在失真的情况；
* canvas绘制的图形不会出现在DOM结构中，svg绘制的会存在于DOM结构中；
* canvas每次图形的改变都是先清除原来的图形，然后把新的图形画上去，svg则是可以直接通过js来进行某些操作。



#### 16、for和forEach的区别

* forEach 没有 break，使用会报错；但是for里面可以使用break；

* forEach 里面 return 无效（在forEach中使用return是不能跳出循环的）；但是for里面使用return有效；

* forEach 在循环的过程中无法进行左右索引；但是 for 可以 。



#### 17、遍历对象的方法

**1、for...in**

```JavaScript
var obj = {
        name: 'yqq',
        age: 18
    }
for (let key in obj) {
    console.log(key, obj[key]);  // name, yqq  age, 18
}
```

**2、Object.keys(obj)  /  Object.values(obj)**

```JavaScript
var obj = {
        name: 'yqq',
        age: 18
    }
Object.keys(obj);  // ["name", "age"]
Object.values(obj); //  ["yqq", 18]
```

**3、Object.getOwnPropertyNames(obj)**

```JavaScript
var obj = {
        name: 'yqq',
        age: 18
Object.getOwnPropertyNames(obj);  // ["name", "age"]
```

**4、Reflect.ownKeys(obj)**

```js
var obj = {
        name: 'yqq',
        age: 18
    }
Reflect.ownKeys(obj);  // ["name", "age"]
```



#### 18、常用的loader和plugin

###### 18.1 loader

1、loader的配置方式：

在配置文件`webpack.config.js`中配置。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  }
}
```

2、loader的配置规则：

从下到上，从右到左

3、常见的loader：

* 样式：style-loader、css-loader、less-loader、sass-loader等

* 文件：raw-loader、file-loader 、url-loader等

* 编译：babel-loader、coffee-loader 、ts-loader等

* 校验测试：mocha-loader、jshint-loader 、eslint-loader等

4、**可说一下项目中用到的loader：**

```text
less-loader, css-style, style-loader
```

比如下面配置，可以匹配 .less 的文件，分别经过less-loader、css-loader、style-loader的处理。 `less-loader`转化less为css文件，并且包一层module.exports成为一个js module。`style-loader`将创建一个style标签将css文件嵌入到html中。`css-loader`则处理其中的@import和url()。

```js
module.exports = {
  module: {
    rules: [
        {
          test: /\.scss$/,
          use:[
              {loader:'style-loader'},
              {loader:'css-loader',options:{sourceMap:true,modules:true}},
              {loader:'less-loader',options:{sourceMap:true}}
          ],
          exclude:/node_modules/
      }
    ]
  }
}
```

###### 18.2 plugin

webpack的plugin比loader强大，通过钩子可以涉及整个构建流程，可以做一些在构建范围内的事情。

1、plugin的作用：

总结来说 Plugin 的作用如下：

* 提供了 Loader 无法解决的一些其他事情；
* 提供强大的扩展方法，能执行更广的任务

2、可以说一下项目中用到的plugin：

```text
html-webpack-plugin
```



#### 19、ES6

ES6更新的内容主要分为以下几点

- **表达式**：声明、解构赋值
- **内置对象**：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect
- **语句与运算**：Class、Module、Iterator
- **异步编程**：Promise、Generator、Async

![ES6缩略](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f623a94c2f6f4cbeb46b1e8d66e75186~tplv-k3u1fbpfcp-watermark.awebp)



#### 20、数组扁平化：

```JavaScript
function flatten(arr) {
        return arr.reduce((result, item) => {
            return result.concat(Array.isArray(item) ? flatten(item) : item);
        }, []);
    }
console.log(flatten([1, 2, [3], [4, 5, [6]]])); // [1, 2, 3, 4, 5, 6]
```



#### 21、JS数组和类数组的区别

1、类数组的定义：

1）拥有length属性；

2）不具有数组所拥有的方法。

javascript中常见的类数组有 `arguments`对象和 DOM方法的返回结果。比如 `document.getElementsByTagName('div')`

2、判断是否是类数组：

```JavaScript
function isLikeArray(o) {
    if (typeof o === 'object' && isFinite(o.length) &&  o.length >= 0 && o.length < 4294967296){
        // 4294967296: 2^32
        return true
    } else {
        return false
    }
}
```

3、类数组转化为数组：

`args = Array.prototype.slice.call(arguments);`

类数组转换为数组首先Array.prototype.slice.call(arguments)的结果是将arguments对象转换成一个Array对象。所以其后面可以直接调用数组具有的方法.

通过拓展运算符也可：

`args = [...arguments]`



#### 22、websocket

WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 WebSocket 连接后，你可以通过 **send()** 方法来向服务器发送数据，并通过 **onmessage** 事件来接收服务器返回的数据。

```HTML
<!DOCTYPE HTML>
<html>
<head>
   <meta charset="utf-8">
   <title>W3Cschool教程(w3cschool.cn)</title>
    <script type="text/javascript">
        function WebSocketTest() {
            if ("WebSocket" in window) {
                alert("您的浏览器支持 WebSocket!");
                // 打开一个 web socket
                var ws = new WebSocket("ws://localhost:3000/student");
                ws.onopen = function() {
                    // Web Socket 已连接上，使用 send() 方法发送数据
                    ws.send("发送数据");
                    alert("数据发送中...");
                };
                ws.onmessage = function (e) { 
                    var res = e.data;
                    alert("数据已接收...");
                };
                ws.onclose = function(){ 
                    // 关闭 websocket
                    alert("连接已关闭..."); 
                };
            } else {
                // 浏览器不支持 WebSocket
                alert("您的浏览器不支持 WebSocket!");
            }
        }
    </script>
</head>
<body>
    <div id="sse">
        <a href="javascript:WebSocketTest()">运行 WebSocket</a>
    </div>     
</body>
</html>
```



#### 23、图片懒加载

1、getBoundingClientRect().top

显示器高度：`window.innerHeight`

图片到显示器的高度：`getBoundingClientRect().top`

如果图片到窗口顶部的距离大于窗口的高度，则图片可以先不加载；如果图片到窗口顶部的距离小于窗口的距离，则图片可以进行加载。

```html
<body>
    <img data-src = "1.gif">
    <img data-src = "2.gif">
    <img data-src = "3.gif">
</body>
```

```js 
const images = document.querySelector('img');
window.addEventListener('scroll', (e) => {
    images.forEach(image => {
        const imageTop = image.getBoundingClientRect().top;
        if(imageTop < window.innerHeight) {
            const data-src = image.getAttribute('data-src');
            image.setAttribute('src', data-src);
        }
    })
})
```



#### 24、SPA与MPA

1、SPA(Single Pages Application)

单页应用程序是在浏览器中运行的应用程序，在使用过程中不需要重新加载页面。

它们比传统的 Web 应用程序更快，因为它们在 Web 浏览器本身而不是在服务器上执行逻辑。在初始页面加载后，只有数据来回发送，而不是整个 HTML，这会降低带宽。它们独立请求标记和数据，并直接在浏览器中呈现页面。

优点：

* SPA速度和响应能力更快，服务器不需要在每次交互时加载大多数资源；
* 代码间的耦合度较低，使得前后端分离更加容易，且维护起来也更加方便。

缺点：

* 首屏加载速度慢，因为在加载首页的时候会请求所需的所有的资源；
* 不利于SEO。



2、MPA(Multiple Pages Application)

多页面应用程序具有更经典的架构。每个页面都会向服务器发送请求并完全更新所有数据。即使这些数据很小，也会影响速度和性能。

优点：

* 易于SEO；
* 易于开发与维护。

缺点：

* 前后端难分离，代码耦合度较高；
* 耦合度较高所有无法复用重复的代码。

#### 25.进程和线程
* 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位。
*  一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。
*  进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见。
*  调度和切换：线程上下文切换比进程上下文切换要快得多。

